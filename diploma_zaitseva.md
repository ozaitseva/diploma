#Криминалистически правильные методы обработки дампов физической памяти операционных систем семейства Windows NT

#Forensically sound methods of Windows NT volatile memory dump processing

# Введение

## Актуальность

Наряду с появлением новых изобретений в сфере компьютерных и информационных технологий, появляются принципиально новые общественные отношения, которые и становятся предметом преступных посягательств. Почти каждый человек сегодня пользуется компьютером, платежными терминалами, мобильным телефоном и прочими современными технологиями, но вместе с этим и у злоумышленников появляются новые средства и орудия для совершения преступлений: эксплуатация уязвимостей серверов с публичными веб-сайтами, несанционированное проникновение в электронную почту, внедрение в инфраструктуру платежных систем и т.п. Например, даже кража или мелкое мошенничество часто совершаются сегодня при помощи сети Интернет.

Наука, которая занимается раскрытием, расследованием и предотвращением такого рода преступлений – преступлений, связанных
с компьютерной информацией, – называется *компьютерной криминалистикой* или *компьютерной форензикой* (с английского computer forensics) [1]. Естественно, она включает в себя как методы сбора, обработки и анализа доказательств, представленной в виде компьютерной информации (так называемых цифровых доказательств), так и применяемый для этого программно-аппаратный инструментарий.
Термин «форензика» произошел от латинского «foren», что значит «речь перед форумом», т.е. выступление перед судом,
судебные дебаты. В русский язык это слово пришло из английского. Термин «forensics» является сокращенной формой «forensic science», дословно «судебная наука», т.е. наука об исследовании доказательств – именно то, что в России именуется криминалистикой [1].
При заимствовании, слово «форензика» сузило свое значение и часто применяется в ИТ-контексте.

Компьютерная криминалистика ориентирована на решение задач cбора и анализа цифровой информации, хранящейся в запоминающих устройствах компьютера.

В отличие от традиционных разделов криминалистики, таких как дактилоскопия, баллистика, которые развиваются уже давно,
компьютерная криминалистика – наука новая, которая родилась совсем недавно, и в России только недавно оформилась в полноценное направление криминалистической науки. Но несмотря на то, что ее опыт и инструментарий пока невелики, имеются множество предпосылок для бурного развития данной науки.

Законодательство Российской Федерации нацелено на использование современных программных и аппаратных средств. Так, согласно
ст. 11 Федерального закона «О полиции» [2], «полиция в своей деятельности обязана использовать достижения науки и техники,
информационные системы, сети связи, а также современную информационно-телекоммуникационную инфраструктуру». В настоящее время
полиция использует средства аудио-, фото- и видеофиксации при проведении следственных действий и оперативно-розыскных мероприятий.
Согласно уголовно-процессуальному кодексу Российской Федерации при производстве следственных действий допускается применение
технических средств - п. 6 ст. 164 УПК [3] «при производстве следственных действий могут применяться технические средства
и способы обнаружения, фиксации и изъятия следов преступления и вещественных доказательств».

Нетрудно заметить, что в ближайшем будущем при раскрытии компьютерных преступлений невозможно будет обойтись без актуального,
современного программно-аппаратного оснащения, необходимого для исследования цифровых носителей информации.

Компьютерная криминалистика применяется в следующих сферах [1]:

* Раскрытие и расследование уголовных и гражданских преступлений, связанных с компьютерной информацией, которая может быть как объектом посягательства, так и орудием совершения преступления или доказательством;
* Расследования инцидентов информационной безопасности в компаниях, работающих с информацией, содержащей коммерческую тайну и иные конфиденциальные данные;
* Поиск, уничтожение, восстановление и защита компьютерной информации в военных и разведывательных задачах;
* Защита личной информации граждан, представленной в электронном виде.

Процесс, цель которого раскрыть совершенное компьютерное преступление, принято делить на 4 этапа [1]:

1. Сбор: извлечение информации и источников информации, а также использование специализированных программно-аппаратных средств для этого. При сборе необходимо оставить пометку с указанием источников и происхождения данных и объектов, также следует обеспечить сохранность, целостность (неизменность) и конфиденциальность данных.
2. Исследование: извлечение и обработка информации.
3. Анализ: собранная информация изучается и анализируется с целью поиска ответов на вопросы, которые стоят перед специалистом или экспертом.
4. Представление: оформление результатов исследования и анализа в установленной законом и понятной неспециалистам форме.

Информация, представляющая интерес для исследователя, может быть различной по виду и содержанию: сетевые соединения, имена пользователей и пароли, удаленные файлы и многое другое. Данная информация хранится в различных подсистемах компьютера, поэтому существуют и различные методы, которые применяются для обработки цифровых данных и ориентированные на [4]:

* Снятие образов памяти и служебных данных (англ. acquisition) с персистентных носителей данных (в большенстве случаев дисковых накопителей) и оперативной памяти;
* Анализ данных оперативной памяти (англ. memory analysis) и накопителей (англ. data carving).

В данной работе основное внимание уделяется методам сбора и анализа образов оперативной (физической) памяти.

Любая активно используемая информация (например, прошлые и текущие сетевые соединения, список запущенных процессов, имена пользователей и пароли, содержимое открытых окон графичнского интерфейса пользователя, открытые ключи реестра) для оптимизации производительности хранится операционными системами в оперативной памяти. Этот факт указывает на то, что методы извлечения и анализа данных энергозависимой памяти критически важны при проведении компьютерно-криминалистических исследований.

Для извлечения и анализа содержимого физической памяти используются аппаратные и программные средства. Однако данные подходы имеют большое количество существенных недостатков, что делает невозможным их использование при проведении компьютерно-криминалистических исследований.  Главный недостаток программных средств состоит в том, что они в той или иной степени модифицируют память целевой системы, что является недопустимым. 


## Цель работы

Разработать и реализовать криминалистически правильные методы обработки дампов физической памяти операционных систем семейства Windows NT в контексте создания криминалистического программного комплекса, интегрированного с платформами виртуализации и позволяющего производить неинвазивный анализ динамики оперативной памяти.

## Задачи

Для успешного достижения поставленной цели необходимо:

* исследовать существующие методики анализа внутренней памяти;
* изучить устройство памяти операционных систем семейства Windows 7 x86-64;
* разработать методы обработки дампов физической памяти;
* реализовать и апробировать полученные методы анализа дампов физической памяти. 

# Глава 1. Обзор существующих средств и методов

На данный момент существует большое количество программно-аппаратных средств для извлечения и анализа данных физической памяти компьютеров, работающих под управлением операционных систем Windows NT. Однако, выбор того или иного средства для криминалистического метода обработки цифровой информации необходимо делать, исходя из следующей базовой классификации:

* криминалистически правильные;
* криминалистически сомнительные;
* криминалистически неправильные.

На ряду с последней, средства (и основанные на них методы) подразделяются по требованию к рабочему состоянию исследуемого оборудования:

*	методы, не требующие остановки целевой системы;
*	методы, приостанавливающие целевую систему.

Наконец, все средства и методы могут быть разделены по мере воздействия на память операционной системы:

*	инвазивные – методы, которые модифицируют память в той или иной степени;
*	неинвазивные - методы, которые не требуют наличия в памяти своего резидентного кода, тем самым не оставляют следов.

Рассмотрим конкретные примеры существующих программных и аппаратных средств.

К аппаратным средствам относятся [5]:

*1. Шина FireWire.* Данное устройство обеспечивают извлечение данных физической памяти, используя прямой доступ к памяти (DMA, Direct Memory Access), то есть они могут получить доступ к системной памяти без прохода через центральный процессор. Отображение памяти выполняется на аппаратном уровне, минуя основную операционную систему, что обеспечивает быстрый доступ к данным и быструю передачу данных. Ясно, что данный метод относится к неинвазивным методам, не останавливающим целевую систему, но нельзя говорить, что он является криминалистически правильным методом, т.к. часть данных может быть пропущена при копировании постоянно изменяющихся данных;

*2. Карты расширения Tribble.* Данный механизм может быть использован для копирования содержимого физической памяти на внешнее устройство, не вводя никакого дополнительного программного обеспечения в систему, тем самым сводя к минимум модификацию данных, т.е. является неинвазивным методом. Карты расширения также используют подход, основанный на доступе к памяти через DMA, именно поэтому этот инструмент является криминалистически сомнительным в связи с потерей части данных, а также еще один недостаток заключается в том, что оборудование должно быть установлено до происшествия.

К программным средствам относятся:

*1. Аварийные дампы.* Данный способ позволяет получить не модифицированную копию содержимого оперативной памяти системы Windows с помощью создания причины дампа. Когда происходит аварийный дамп, система замораживается и содержимое оперативной памяти записывается на диск. Это сохраняет состояние системы и гарантирует, что никакие изменения не будут внесены в систему после того, как был вызван аварийный дамп. Таким образом, метод аварийного дампа относится к неинвазивным методам, приостанавливающим систему. Однако, он в то же время является криминалистически сомнительным, т.к.:

*	некоторые системы Windows не генерируют полные аварийные дампы по умолчанию;
*	 изменение системы для приема последовательности нажатий клавиш для создания дампа требует перезагрузки и должно быть сделано заранее.

*2. Такие утилиты, как Belkasoft Live RAM Caputer, MANDIANT Memoryze, HBGary, FTK Imager, Volatility Framework и др.* Данные средства являются инвазивными, и как следствие, криминалистически неправильными. 

В целом можно выделить, что главный недостаток аппаратных средств, также, как и программных, заключается в их высокой стоимости. Помимо данного факта, программные решения являются труднодоступными, поддерживают не все форматы дампов оперативной памяти компьютера, имеют закрытый исходный код, что не позволяет их модифицировать под конкретные задачи. 

# Глава 2. Обзор устройства внутренней памяти Windows 7 на платформе x86-64. 

Для проведения анализа образа оперативной памяти сначала необходимо изучить, как устроена память конкретной операционной системы.
Ниже представлен краткий обзор устройства внутренней памяти Windows 7 на платформе x86-64.

Часть операционной системы, которая отвечает за управление памятью, называется менеджером или диспетчером памяти. Говоря о системе
управления памятью, используют понятия физической и виртуальной памяти.

Под физической памятью подразумевается оперативная память, которая представляет упорядоченный набор однобайтовых ячеек, каждая из которых имеет свой уникальный адрес.
Совокупность адресов в физической памяти, используемых для идентификации хранимых в памяти данных, называется физическим адресным пространством.
Виртуальная память - это абстрактное хранилище, используемое для хранения данных процессов, позволяющее программе «считать», что ей предоставлен неограниченный объем
памяти и непрерывное адресное пространство памяти. Объем виртуальной памяти равен объему максимально адресуемой памяти. Виртуальное адресное пространство процесса в
архитектуре x86-64 теоретически может составлять 16 экзабайт (2^64 байт) [6]. Понятно, что у современных компьютеров нет необходимости поддерживать такой объем
памяти, поэтому чтобы упростить архитектуру микросхем и уменьшить число издержек в нынешних процессорах x64 производства AMD и Intel реализовано только 256 Тбайт
виртуального адресного пространства, то есть реализованы только младшие 48 разрядов 64-разрядного виртуального адресного пространства. Однако разрядность виртуального
адреса все равно составляет 64 бита, тем самым занимая 8 байт в регистрах. В результате чего появилось требование, чтобы старшие 16 разрядов (48-63) имели значение
равное старшему реализованному разряду (47). Адреса, удовлетворяющие данному требованию, называются «каноническими» и имеют следующие значения: 0x0000000000000000 - 0x00007FFFFFFFFFFF, а также 0xFFFF800000000000 -  0xFFFFFFFFFFFFFFFF [6].

Виртуальная память в операционной системе Windows имеет сегментно-страничную организацию. Отличительной чертой данной модели является то, что адресное пространство процесса представляется в виде набора сегментов переменного размера. Для удобства преобразования (трансляции) виртуального адреса в физический каждый сегмент делится на страницы - блоки фиксированного размера, при этом физическая память делится на блоки того же размера - страничные кадры (фреймы).
Процессоры, на которых работает Windows, поддерживают страницы двух размеров — малые, размером 4 КиБ, и большие, размером 2 МиБ. [7] По умолчанию адресное
пространство каждого процесса изолировано, то есть не может возникнуть такой ситуации, что данные двух разных процессов будут записаны в одну и ту же страницу
физической памяти. За преобразование виртуального адреса в физический отвечают таблицы страниц, которые каждой виртуальной страницы ставит в соответствие страничный кадр.
Возможны две схемы преобразования адреса для Windows на платформе x86: с расширением физических адресов (Physical Address Extension, PAE) и без него. Системы на платформе x86 без
поддержки PAE для преобразования виртуальных адресов в физические используют двухуровневую структуру таблицы страниц, состоящую из каталога страниц (page directory, PD) и
таблицы страниц (page table, PT). Виртуальный адрес представляется в виде двух полей: поля номера виртуальной страницы (virtual page number), который в свою очередь
делится на два подполя: индекс каталога страниц (page directory index) и индекс таблицы страниц (page table index), и поля байтового смещения (byte offset).
В данной работе будет рассмотрена архитектура x86-64, так как большинство современных процессоров поддерживает именно эту систему команд.
Системы на платформе x86-64 для трансляции адресов используют схему, схожу со схемой с поддержкой PAE.
Они используют четырехуровневую структуру таблицы страниц. 48-разрядный виртуальный адрес представляет собой совокупность 5 полей (см. рис 2.1.):
селектора четвертого уровня отображения страницы (биты 47-39), селектор указателя каталога страниц (биты 38-30), селектор таблицы страниц (биты 29-21),
селектор записи таблицы страниц (биты 20-12) и байтовое смещение (биты 11-0). Эти поля служат для локализации записей в соответствующих таблицах преобразования (см. рис 2.2.) [6].

![Виртуальный адрес на платформе x86-64] (https://github.com/ozaitseva/diploma/blob/master/images/virt_adr.jpg "Виртуальный адрес на платформе x86-64")

![Структуры преобразования адресов на платформе x86-64](https://github.com/ozaitseva/diploma/blob/master/images/transl_adr.jpg "Структуры преобразования адресов на платформе x86-64")

Записи (такие как PDPE, PDE, PTE и др) в нижеописанных таблицах преобразования представляют собой 8-байтные значения (см. рис 2.3.). Биты с номерами 12-39 образуют
значения PFN (page frame number), которые указывают на физический адрес таблицы предыдущего уровня. Оставшиеся биты — это флаги,
указывающие на состояние страниц.

![Аппаратная запись таблицы страниц на платформе x86-64](https://github.com/ozaitseva/diploma/blob/master/images/pte.jpg "Аппаратная запись таблицы страниц на платформе x86-64")

В поставленной в данной работе задаче необходимо восстановить виртуальное адресное пространство процесса, используя снятый образ физической памяти,
то есть провести преобразования известных виртуальных адресов в соответствующие им физические, тем самым получив данные всех страниц виртуальной памяти
из кадров (фреймов) оперативной памяти.

##Преобразование виртуального адреса в физический

Преобразования физического адреса выполняется в несколько этапов [7]:

Шаг 1: Найти физический адрес записи расширенного каталога страниц четвертого уровня, называемого таблицей отображения страниц четвертого уровня (page map level 4), который имеет следующую структуру:

* Биты 51-12 совпадают со значениями битов 51-12 поля DTB,
* Биты 11-3 соответствуют битам 47-39 виртуального адреса,
* Биты 2-0 равны нулю.

Шаг 2: Найти физический адрес записи структуры третьего уровня, которая называется PDPT (page directory pointer table). Физический адрес имеет аналогичный предыдущей записи вид:

* Биты 51-12 из записи таблицы PML4,
*	Биты 11-3 соответствуют битам 38-30 виртуального адреса,
*	Биты 2-0 равны нулю.

Шаг 3: Найти значение PS-флага (бит 7) записи таблицы PDPT:

*	если флаг принимает значение 1, то данная запись ссылается на большую страницу, размером 1 ГиБ. Записав PFN-номер из данной записи в биты 51-30 и значение смещения
из виртуального адреса в биты 29-0, получаем искомый соответствующий данному виртуальному физический адрес,
*	если флаг равен нулю, то переходим к шагу 4.

Шаг 4: Найти физический адрес записи каталога страниц второго уровня - таблицы PD (page directory). Структура соответствующего физического адреса:

*	Биты 51 — 12 соответствуют битам 51-12 записи таблицы PDPT,
*	Биты 11-3 равны битам 29-21 виртуального адреса,
*	Биты 2-0 имеют нулевое значение.

Шаг 5: Найти значение PS-флага записи таблицы PD:

*	если флаг равен 1, то PDE указывает на страницу, размер которой составляет 2 МиБ. В данном случае
получаем физический адрес, у которого значения битов 51-21 хранятся в записи таблицы PDE, а значения 20-0  - из виртуального адреса,
*	В противном случае переходим к шагу 6.

Шаг 6: Найти физический адрес записи таблицы страниц (page table):

*	биты 51-12 физического адреса записи совпадают с 51-12 битами PDE,
*	биты 11-3  - биты 20-12 виртуального адреса,
*	биты 2-0 равны нулю.

Шаг 7: Найти физический адрес соответствующий данному виртуальному:

*	Биты 51-12 из PTE-записи,
*	Биты 11-0 — смещение из виртуального адреса.

Таким образом, после преобразования получаем физический адрес, соответствующий текущему виртуальному адресу.

Если в PTE-записи бит достоверности (0 бит) принимает нулевое значение, то это значит, что в данный момент страница недоступна процессу,
то есть данная PTE-запись предоставляет недостоверную страницу.  При ссылке на такую страницу, диспетчер памяти выдает ошибку отсутствия страницы,
блок управления память в свою очередь игнорирует все остальные биты PTE-записи, поэтому операционная система может использовать эти биты для хранения
информации о странице, ставшей причиной выдачи ошибки.

Существует пять видов недостоверных PTE-записей [6]:

1. Файл подкачки (*Page File PTE*). Биты *V* (0), *P* (10), *U* (11) равны нулю. Искомая страница находится в файле подкачки. В данном случае биты 1-4 ссылаются
на один из шестнадцати файлов подкачки, а биты 12-51 указывают на смещение в данном файле. Файлы подкачки используются для хранения страниц, которые еще
могут понадобиться, но места для их хранения в оперативной памяти нет, поэтому они записываются на диск. Если минимальный и максимальный размер файлов подкачки,
на которые указывает параметр реестра *HKLM\SYSTEM\CurrentControlSet\Control\SessionManager\MemoryMange-ment\PagingFiles*, равны нулю, то это указывает на то,
что данный файлы управляются системой. Система выбирает размер данных файлов, исходя из объемов оперативной памяти. Смещение в файле подкачки никогда не бывает
нулевым и не может полностью состоять из единиц, то есть первая и последняя страницы из файла подкачки никогда не используются для самой подкачки.
Найдя данную запись, необходимо вернуть соответствующие данные из файла подкачки.

2. Заполнение нулями (*Demand Zero PTE*). Данная PTE-запись совпадает с предыдущим видом, но поле, отвечающее за смещение в файле подкачки,
и поле, ссылающееся на сам файл, полностью заполнены нулями. В данном случае обработчик ошибок выберет свободную страницу из списка страниц,
заполненных нулями, а в случае, если такой список пуст, то берет свободную страницу и заполняет ее нулями, если же и свободных страниц нет, то выбирает
одну из страниц, ожидающих использования, и заполняет ее нулями. Следовательно, получив данную запись, необходимо вернуть страницу, состоящую из нулей.

3. Переходное состояние (*Transition PTE*). Бит *U* (11) содержит единицу, биты *V* (0) и *P* (10) равны нулю. Искомая страница находится в списке ожидающих использования
или измененных, но еще не записанных страниц. Именно поэтому страница запись данного вида обрабатывается как действительная.

4. Прототипная PTE-запись (*Prototype PTE*). Бит *P* (10) равен единице. Записи таблицы страниц такого вида используется для отображения страниц, которые используются
несколькими процессами. Формат прототипных записей таблиц страниц аналогичен формату выше рассмотренных PTE-записей. Записи данного типа имеют собственную классификацию,
в следствие чего их обработка рассмотрена ниже.

5. Неизвестная страница (*Zero PTE*). PTE-запись заполнена нулями. С помощью диспетчера управления ошибок и VAD-дескрипторов можно узнать, был ли данный виртуальный адрес
подтвержден. Больше никакой информации о данной странице получить невозможно.

Если бит достоверности PML4-записи, PDPT-записи или PDE равен нулю, то есть данные страницы являются недействительные, то их следует обрабатывать также, как *Page File PTE* или *Transition PTE*.

Особое внимание стоит уделить обработке прототипных записей. Страницы, на которые ссылаются данные записи, не используются в процессе
преобразования адресов напрямую, а лишь являются промежуточным уровнем поиска номера страничного блока. Адрес прототипной страницы получается следующим образом:

*address = (PTE >> 16) + 0xFFFF000000000000*.

Найденная страница может находить в одном из шести состояний[6]:

* Активна/достоверна. Бит *V* (0) равен 1. Данная страница находится в физической памяти и обрабатывается как действительная.
* Переходное состояние. Бит *U* (11) равен 1. Искомая страница находится в оперативной памяти и ожидает использования, либо была изменена.
При обработке необходимо вернуть страницу из памяти.
* Изменение без записи. Бит *D* (6) равен 1. Искомая страница была изменена, но не записана.  
* Заполнение нулями. Биты *P* (10), *U* (11) равны 0, а также поле, отвечающее за смещение в файле подкачки, и поле, ссылающееся на сам файл,
имеют нулевые значения. В качестве искомой должна быть предоставлена страница, заполненная нулями.
* Страничный файл. Биты *P* (10), *U* (11) равны 0. Необходимо вернуть страницу из файла подкачки.
* Отображаемый файл. Бит *P* (10) равен 1. Искомая страница находится в отображаемом файле.

## Процессы и потоки

Каждый процесс ОС Windows представлен структурой *\_EPROCESS* [8]. Данная структура содержит атрибуты, описывающие процесс, а также другие связанные с ним данные (например, структуру *\_ETHREAD*, описывающую потоки процесса).

Windows использует круговой двусвязный список структур EPROCESS для отслеживания процесса исполнения (см. рис. 2.4.). Ссылки, связывающие объекты EPROCESS, содержатся в поле ActiveProcessLink, структура которого LIST_ENTRY.
```
typedef struct _LIST_ENTRY {
struct _LIST_ENTRY  *Flink;
struct _LIST_ENTRY  *Blink;
}
```

![Двусвязный список процессов](https://github.com/ozaitseva/diploma/blob/master/images/proc_list.jpg "Рис. 4. Организация двусвязного списка процессов")

Структуры *\_EPROCESS* располагаются в адресном пространстве ядра. Первым элементом структуры процесса является блок управления процессом, представленный структурой *\_KPROCESS*, также находящийся в пространстве ядра. В структуре *\_KPROCESS* хранится вся информация, касающаяся планированию потоков, ведь каждый процесс содержит хотя бы один поток, представленный структурой *\_ETHREAD*.

```
typedef struct _EPROCESS {
+0x000 Pcb _KPROCESS {
+0x000     Header DISPATCHER_HEADER{
union {
struct{
+0x000 UINT8        Type;
...
+0x002 UINT8        Size;
       }
...
       }
+0x018     ProfileListHead LIST_ENTRY;
+0x028     UINT64 DirectoryTableBase;
...
       }
...
+0x308 ThreadListHead LIST_ENTRY {
+0x000 Flink PLIST_ENTRY;
+0x008 Blink PLIST_ENTRY;
...
}
```
## Внутреннее устройство реестра

Реестр в Windows - иерархически построенная база данных параметров и настроек в большинстве операционных систем Microsoft Windows [8]. Он используется приложениями
операционной системы для хранения всевозможной информации, начиная от простых конфигурационных данных и заканчивая конфиденциальными данными, такими как пароли
учетных записей и ключами. Реестр может быть важным источником доказательств при проведении компьютерно-криминалистических исследований. Он содержит такую информацию,
как недавно запущенные программы, журнал недавно подключенных устройств, сетевые соединения.

Внутреннее устройство реестра схоже с устройством дискового тома. Разделы реестра — это аналог каталогов диска, а параметры можно сравнить с файлами на диске.
Раздел реестра состоит из подразделов или из параметров, в которых хранятся сами данные. Самые верхние разделы считаются корневыми.
На диске реестр представлен набором файлов, которые носят название хайвы (англ. hive). Каждый хайв содержит дерево реестра, у которого есть раздел,
служащий ему корнем или отправной точкой дерева. Подразделы и их параметры находятся ниже корня. Диспетчер конфигурации делит хайв на логические блоки также, как
файловая система делит диск на кластеры. По определению, размер блока реестра составляет 4096 байт (4 Кб). Хайв хранит данные в контейнерах, которые называются ячейки.
В ячейке хранятся разделы, параметры, список подразделов и параметров раздела. Ячейка может быть одного из пяти типов [8]:

1.	ячейка раздела – представлена структурой CM_KEY_NODE и содержит раздел реестра. В ней содержится такая информация, как индекс родительской ячейки, индекс ячейки списка подразделов данного раздела, отметка времени последнего обновления раздела.
Отличительной особенностью данной ячейки в памяти является сигнатура “kn” для раздела и “kl” для ссылки раздела;

2.	ячейка параметра – представлена структурой CM_KEY_VALUE, содержит информацию о параметре раздела – тип и имя, а также индекс ячейки, содержащей данные параметра. Данная ячейка имеет сигнатуру “kv”;

3.	ячейка списка подразделов – представлена структурой CM_KEY_INDEX, содержит список индексов ячеек разделов – подразделов родительского раздела;

4.	ячейка списка параметров – представлена структурой CM_KEY_INDEX и включает в себя список индексов ячеек параметров – подразделов родительского раздела;

5.	ячейка дескриптора безопасности – представлена структурой CM_KEY_SECURITY, в нее записывается количество узлов раздела, совместно использующих дескриптор безопасности. Данная ячейка начинается с сигнатуры “ks”.

Если хайв должен быть расширен в следствие прибавления новой ячейки, создается единичный
блок — приемник (англ. bin). За смещение ячейки в файле хайва отвечает индекс ячейки (за вычетом базового блока). Местонахождение ячейки в памяти может быть вычислено
путем прибавления индекса ячейки к базе образа хайва.

Каждый хайв в ОС Windows представлен структурой *\_CMHIVE* [4]. В структуре *\_CMHIVE* содержится метаданные о хайве, такие как полный путь, число открытых дискрипторов, и
указатели на другие хайвы (структура *\_LIST\_ENTRY*). Данная структура начинается с субструктуры *\_HHIVE*, в которой содержится виртуальный адрес базового блока хайва,
представленного структурой *\_HBASE_BLOCK*.

```
typedef struct _CMHIVE {
+0x000 struct _HHIVE Hive{
+0x000 ULONG32 Signature;
...
+0x050 struct _HBASE_BLOCK* BaseBlock;
...
+0x0A8 struct _DUAL Storage[2];
}
...
+0x5D8 struct _LIST_ENTRY HiveList;
...
}
```
В следствие того, что хайв может расширяться, т.е. добавляются новые ячейки, данные хайва хранятся в памяти непоследовательно.
Для работы с непоследовательными адресами памяти, диспетчер конфигурации использует метод, схожий с тем, что используется диспетчером памяти Windows для
отображения адресов виртуальной памяти в физические адреса. 

![Трансляция индекса ячейки в памяти](https://github.com/ozaitseva/diploma/blob/master/images/cell_index_transl.jpg "Трансляция индекса ячейки в памяти")

Для отображения ячеек индекс ячейки делится на три поля (см. рис. 2.5.):
индекс в каталоге отображения ячеек – биты 1-10,
индекс в таблице отображения ячеек – биты 11-19 и смещение в карте ячеек – биты 20-31. Бит 0 является флагом, указывающим, где хранятся данные хайва – в основной или в оперативной памяти.
Каталог отображения ячеек содержит 1024 записи, каждая из которых ссылается на таблицу отображения ячеек,
содержащую 512 записей отображений. Виртуальный адрес, указывающий на массив виртуальных адресов каталогов отображения
ячеек хранится в подструктуре структуры *\_HHIVE* - *Storage[2]* в поле *Map* [8].

## Глава 3. Методы обработки дампов оперативной памяти компьютеров

## Поиск процессов и потоков

Поиск процессов и потоков в дампе памяти сводится к поиску структур *\_EPROCESS*, а, следовательно, и структур *\_KPROCESS* и *\_KTHREAD*.  Структуры *\_KPROCESS* и *\_KTHREAD* начинаются с субструктуры, известной как *\_DISPATCHER\_HEADER*. В ней содержатся поля *Type* и *Size*, определяющие тип и размер объекта соответственно, которые принимают одинаковые значения для всех процессов конкретной операционной системы [4] (см. табл. 3.1.).

**Таблица 3.1.** Байтовые паттерны для поиска структуры *\_DISPATCHER\_HEADER* для разных версий Windows.

| Версия Windows | Байтовый паттерн    |
|----------------|:-------------------:|
| XP x86         | 0x03 0x00 0x1B 0x00 |
| 2003 x86       | 0x03 0x00 0x1E 0x00 |
| 2003 x86-64    | 0x03 0x00 0x2E 0x00 |
| Vista x86      | 0x03 0x00 0x20 0x00 |
| Vista x86-64   | 0x03 0x00 0x30 0x00 |
| 7 x86          | 0x03 0x00 0x26 0x00 |
| 7 x86-64       | 0x03 0x00 0x58 0x00 |



Найдя соответствующие байтовые паттерны в адресном пространстве ядра дампа памяти, можно найти кандидаты на структуру *\_EPROCESS*.

Среди кандидатов могут оказаться не интересующие нас байтовые последовательности, которые, например, находятся в адресном пространстве пользователя,
поэтому необходимо проводить проверку. Именно, следует проверять, что последующий и предыдущий потоки процесса находятся в виртуальном адресном пространстве ядра [9]:

* *ThreadListHead.Flink >= 0xFFFF800000000000*,
* *ThreadListHead.Blink >= 0xFFFF800000000000*.

Проверив данное условие, мы откинем процессы-кандидаты, которые находятся в адресном пространстве пользователя.
Также исключить некорректные кандидаты можно с помощью условия, наложенного на значение управляющего регистра *CR3*, а, следовательно,
и на значение поля *DirectoryTableBase* – биты 63-40 должны быть нулями [7].
Найдя структуру процесса, по значению поля DirectoryTableBase, хранящегося в структуре *\_KPROCESS*, можно получить физический адрес таблицы
преобразования четвертого уровня PML4, а по значениям полей *ThreadListHead.Flink* и *ThreadListHead.Blink* виртуальные адреса последующего и предыдущего потоков соответственно.

## Поиск файлов реестра

Поиск хайвов в физической памяти осуществляется в два этапа [10].

**Шаг 1**: сканируем физическую память с целью поиска структуры *\_CMHIVE*. Это сделать достаточно легко, так как подструктура данной структуры  -  *\_HHIVE* начинается с постоянного значения поля *Signature* — *0xBEE0BEE0*.

**Шаг2**: проверяем на корректность найденные структуры. Корректные структуры должны иметь pool tag *«CM10»*.

Данных показателей достаточно, чтобы найти действительные структуры *\_HHVE* в Windows 7. Найдя соответствующие структуры, с помощью полей *HiveList.Flink* и *HiveList.Blink*
можно получить виртуальные адреса последующего и предыдущего хайвов соответственно, а с помощью поля *BaseBlock* - виртуальный адрес базового блока. Далее необходимо преобразовать
данные адреса в физические, используя значение *DirectoryTableBase* процесса *System*.

Основной блок хайва, представленный структурой *\_HBASE\_BLOCK* также имеет свою константную сигнатуру - *regf* или *0x66676572*. В данной структуре хранится с
ледующая информация: имя файла, путь к файлу, временная отметка и другие системные файлы. Имя файла может содержать максимум 32 символа.
Известно, что каждый хайв содержит набор hive bin (*\_HBIN*). В каждой такой структуре имеется ссылка на последующую такую же структуру.
Данная структура также имеет константную сигнатуру - *hbin*.

Найденный посредством трансляции индекса ячейки RootCell структуры *\_HBASE\_BLOCK* виртуальный адрес указывает на структуру *\_HMAP\_ENTRY*, которая содержит в себе:

```
typedef struct _HMAP_ENTRY {
0x000     UINT64       BlockAddress;
0x008     UINT64       BinAddress;
…
            }

```

Поле *BlockAddress* содержит виртуальный адрес структуры *\_HBIN*. Таким образом, добавив к данному адресу смещение (последние 12 бит), получим адрес, ссылающийся на необходимые нам данные, а именно данные, хранящиеся в структуре *\_CM\_KEY\_NODE*. Данная структура содержит два поля *SubKeyCounts* и *SubKeyLists*, в которых хранится количество подразделов и указатели на список подразделов соответственно [10]. Каждое значение представляет собой массив из двух элементов: первый элемент – постоянный ключ (англ. stable key), второй – переменный ключ (англ. volatile key). Переменные ключи и их значения никогда не хранятся на диске, а автоматически создаются операционной системой во время загрузки.

```
 typedef struct _CM_KEY_NODE {
0x000 UINT16       Signature;
0x002 UINT16       Flags;
0x004 union _LARGE_INTEGER LastWriteTime;
0x00C ULONG32      Spare;
0x010 ULONG32      Parent;
0x014 ULONG32      SubKeyCounts[2];
union {
struct {
0x01C ULONG32      SubKeyLists[2];
0x024 struct _CHILD_LIST ValueList;
};
0x01C struct _CM_KEY_REFERENCE ChildHiveReference;
};
…
}
```

Обходя последовательно все подразделы, можно получить все узлы реестра и их значения.

# Глава 4. Обзор алгоритмов поиска подстроки в строке

Одной из подзадач данной работы является паттерн-анализ дампа физической памяти, т.е. другими словами, поиск конкретной подстроки (байтового паттерна) в строке (дампе физической памяти). На сегодняшний день существует огромное разнообразие алгоритмов поиска подстроки. К таким относятся такие алгоритмы, как: алгоритм Бойера-Мура-Хорспула, автоматный алгоритм Ахо-Корасик, алгоритм Кнутта-Морриса-Прата и др. 

## Алгоритм Бойера-Мура-Хорспула

Алгоритм Бойера-Мура-Хорспула является упрощением алгоритма Бойера-Мура. Процедура алгоритма является очень простой [11]. На первом шаге для каждого символа строится таблица смещений. Далее совмещается начало текста и искомого шаблона с целью сравнения. Если символы шаблона полностью совпали с символами строки, то поставленная задача решена и необходимая подстрока найдена. В противном случае шаблон сдвигается на определенное количество символов вправо. Это количество выбирается по следующему правилу: берется символ строки, оказавшийся над последним символом шаблона, - стоп-символ. Сдвигаем шаблон так, чтобы под стоп-символом оказался такой же символ шаблона. Если стоп-символа в шаблоне нет, шаблон смещается за этот стоп-символ (см. Табл. 4.1.).

![Пример сдвига шаблона](https://github.com/ozaitseva/diploma/blob/master/images/patt_ex_bmh.jpg "Пример сдвига шаблона")

Данное правило реализуется посредством таблицы смещений, в которой каждому символу ставится в соответствие величина, равная разности длины шаблона и порядкового номера символа (если символ повторяется, то берется самое правое вхождение).
Алгоритм продолжается до тех пор, пока шаблон полностью не совпадет с подстрокой или пока не будет достигнут конец строки.

Данный алгоритм прост в реализации и является достаточно быстрым для поиска одного конкретного шаблона в строке, однако его производительность теряется при одновременном поиске нескольких подстрок.

## Алгоритм Кнута-Морриса-Пратта

Алгоритм Кнута-Морриса-Пратта является одним из первых алгоритмов с линейной оценкой в худшем случае. Прежде, чем рассматривать алгоритм, необходимо дать определение понятию префикс-функции от строки.

*Префикс-функция от строки* – это длина наибольшего префикса строки, который одновременно является ее суффиксом, другими словами, это максимальная длина начала строки, которая в то же время является ее концом. Как и в классическом алгоритме поиска подстроки, шаблон сравнивается со строкой слева направо. Однако особенностью данного алгоритма является то, что при помощи префикс-функции можно избежать ненужных сдвигов.

Пусть шаблон *p[0,…,m-1]* наложен на строку *s[0,…,n-1]*, в которой ведется поиск. Рассмотрим сравнение строк на позиции *i*, т.е. шаблона *p[0,…,m-1]* с частью строки *s[i,i+m-1]*. Предположим, что первое несовпадение произошло между *s[i+j]* и *p[j]*, *1<j<m*, и *π[j]* – значение префикс-функции от строки *s[0,…,n-1]* для индекса *j*. Тогда сравнение можно возобновить с места *s[i+j]* и *p[π[j]]*, исключив бесполезные сдвиги [11].

Время работы такого алгоритма линейно зависит от объема входных данных.

## Алгоритм Ахо-Корасик

Алгоритм Ахо-Корасик решает задачу эффективного поиска вхождений всех поступивших на вход шаблонов в заданную строку [12]. Отличительной особенностью данного алгоритма является то, что для решения поставленной задачи в нем используется структура данных – бор, по которой строится конечный детерминированный автомат.

Бор — это дерево, в котором каждая вершина обозначает какую-то строку, корень – это нулевая строка. На ребрах дерева расположен один символ, следовательно, пройдя по всем ребрам из корня в какую-либо вершину и конкатенируя символы ребер, мы получим строку, соответствующую данной вершине. Каждой вершине бора соответствует только одна строка.  

Как было сказано выше, в данном алгоритме необходимо построить конечный детерминированный автомат - такой автомат, в котором нет дуг, не содержащих ни одного символа, и из любого состояния по любому символу возможен переход в точности в одно состояние. Состояние автомата — это какая-то вершина бора. Для перехода автомата из одного состояния в другое используются следующие параметры: текущая вершина v и символ ch. Если из текущей вершины можно перейти по ребру c символом ch, то переходим по нему, иначе переходим по суффиксной ссылке и повторяем процедуру, начиная с новой вершины.

Суффиксная ссылка вершины v - это указатель на вершину u, такую что строка u — наибольший собственный суффикс строки v, или, если такой вершины в боре нет, то указатель на корень. Для получения суффиксной ссылки вершины v необходимо перейти к ее родителю, пройти по суффиксной ссылке родителя и запустить переход из текущей вершины по символу, который указан на ребре родитель-v. Полученная вершина и есть суффикная ссылка вершины v.

Данный алгоритм показывает хорошие результаты в случае, когда нужно искать одновременно несколько постоянных шаблонов.

# Глава 5. Апробация эксперимента

## Настройка рабочего окружения

В качестве рабочей операционной системы использовался дистрибутив Ubuntu, основанный на Debian GNU/Linux.
В настоящее время Ubuntu официально поддерживает только один гипервизор - QEMU-KVM. Для его эффективного использования
процессор должен поддерживать технологию аппаратной виртуализации (Intel VT-x/AMD-V). Базовой операционной системой является
Ubuntu 14.04.2 Server AMD64 (x86-64). Выбор 64-битной платформы объясняется наличием важных для нас возможностей:

* Выделением гостевым системам более 2 ГиБ оперативной памяти.
* Технология виртуализации, которая позволяет эмулировать различное аппаратное обеспечение, а также управлять ресурсами
и изолировать ресурсы между несколькими запущенными гостевыми операционными системами.

В качестве гостевой системы была выбрана Microsoft Windows 7 Professional x64, как одна из наиболее популярных на данный момент операционных систем.

## Постановка эксперимента

В контексте создания криминалистического программного комплекса, позволяющего производить неинвазивный анализ динамики оперативной памяти, необходимо автоматизировать вышеописанные алгоритмы: алгоритмы поиска данных процесса, реестра и алгоритм трансляции виртуального адреса в физический. Схематично их можно представить следующим образом (см. рис. 5.1.):

![Алгоритм поиска процессов и потоков](https://github.com/ozaitseva/diploma/blob/master/images/project_plan_1.jpg "Алгоритм поиска процессов и потоков")

![Алгоритм поиска файлов реестра](https://github.com/ozaitseva/diploma/blob/master/images/project_plan_2.jpg "Алгоритм поиска файлов реестра")

## Результаты эксперимента

Для разработки инструмента был выбран язык программирования Go. На первом шаге средствами гипервизора Qemu/KVM был получен дамп физической памяти интересующей виртуальной машины. Так как задача поиска байтового паттерна в дампе физической памяти сводится к задаче поиска подстроки в строке, был имплементирован алгоритм Бойера - Мура – Хорспула, как самый быстрый из представленных алгоритмов, решающих данную задачу. С помощью данного алгоритма были найдены всевозможные кандидаты на структуры процессов, затем были отброшены некорректные кандидаты путем наложения вышеописанных условий:

```
startKernelAddr := []byte{0xFF, 0xFF, 0x80, 0, 0, 0, 0, 0}
 for i := 0; i < len(thrListHeadF); i++ {
  if bytes.Compare(thrListHeadF[i], startKernelAddr) >= 0 &&
     bytes.Compare(thrListHeadB[i], startKernelAddr) >= 0 &&
     len(byteArrToBinStr(dtb[i])) <= 40 {
      kernEprOffsets = append(kernEprOffsets, eprOffsets[i])
  }
 }
```

Для найденных процессов были найдены значения полей DirectoryTableBase, ThreadListHead.Flink и ThreadListHead.Blink. Полученные виртуальные адреса потоков процесса были транслированы в физические с целью восстановления виртуального адресного пространства процесса.

Помимо процессов также были найдены физические и виртуальный адреса хайвов путем поиска описанных в алгоритме байтовых паттернов и проверки условий:

```
func filterHhiveOffsets(hhiveOffsets []int64, fp string) []int64 {
 var trueHhiveOffsets []int64
 for i := 0; i < len(hhiveOffsets); i++ {
  poolTag, _ := findStruct(hhiveOffsets[i]-12, fp, 4, false)
  if string(poolTag) == "CM10" {
   trueHhiveOffsets = append(trueHhiveOffsets, hhiveOffsets[i])
  }
 }
 return trueHhiveOffsets
}
```

Взяв смещение по данным адресам, были получены физический и виртуальный адрес основного блока каждого хайва, имена файлов реестра.

При трансляции индекса ячейки было обнаружено, что виртуальный адрес, хранящийся в поле BlockAddress, указывает не на начало структуры _HBIN. В связи с тем, что информация, касающаяся реестра ОС Windows, хранится в закрытом доступе, следовательно, выявить причину и адгоритм решения данной проблемы невозможно. Однако эмпирически было выявлено, что если добавить к данному адресу смещение 0x04, то по получившемуся адресу можно найти интересующие нас данные.

В ходе эксперимента было выявлено, что на гостевой операционной системе, дамп физической памяти которой был исследован, запущены следующие процессы (см. Табл. 5.1.):

**Таблица 5.1.** Список найденных процессов

|Физический адрес процесса|Имя процесса  |Физический адрес процесса|Имя процесса  |
|-------------------------|:-------------|:------------------------|:-------------|
|28551C0                  |	Idle         |3E6C1B30                 |winlogon.exe  |
|3E0EDB30                 |SearchProtocol|3E6C9060                 |taskhost.exe  |
|3E207430                 |svchost.exe   |3E71EB30                 |services.exe  |
|3E2435F0                 |svchost.exe   |3E7EB340                 |svchost.exe   |
|3E287060                 |svchost.exe   |3E7F6B30                 |lsass.exe     |
|3E2D76B0                 |mscorsvw.exe  |3E7FCB30                 |lsm.exe       |
|3E2E34B0                 |dwm.exe       |3EEBB650                 |smss.exe      |
|3E2F7310                 |explorer.exe  |3F7C7060                 |sppsvc.exe    |
|3E4BD9E0                 |svchost.exe   |3FAB8630                 |SearchProtocol|
|3E4FA920	            |svchost.exe   |3FAE2B30	           |SearchFilterHo|
|3E5C7B30	            |svchost.exe   |3FC28060	           |mscorsvw.exe  |
|3E62D060	            |spoolsv.exe   |3FC76B30	           |wmpnetwk.exe  |
|3E637920                 |SearchIndexer.|3FC8D6A0                 |svchost.exe   |
|3E68DB30                 |csrss.exe     |3FD63B30	           |calc.exe      |
|3E6A5B30	            |csrss.exe     |3FE36060	           |WmiPrvSE.exe  |
|3E6ABB30	            |wininit.exe   |3FF05360              |svchost.exe   |
|3E6BD350                 |svchost.exe   |3FFF79E0	           |System        |


Полученные данные были проверены и подтверждены с помощью специальных средств отладки Debugging Tools, предназначенных для Windows.

На примере потока процесса System была осуществлена трансляция виртуального адреса потока в физический. Были получены следующие результаты:

*	виртуальный адрес потока процесса System: FFFFFA8000CC0460;
* соответствующий данному виртуальному адресу физический адрес: 3FF3F460;
* значение по данному физическому адресу: FFFFFA8000CCB460.

Используя эти данные, можно проводить анализ системы, основываясь на том, какие приложения запущены и какая информация ими используется. Также стоит обратить внимание и на системные процессы:

* Idle и System – процесс ядра ОС Windows, представляющий собой отдельный поток (или несколько потоков на многоядерных системах), работающий тогда, когда процессор не выполняет других потоков. У данных процессов нет соответствующего исполняемого файла на диске.
* services.exe – управляет службами Windows. Этот процесс должен быть родительским для процесса svchost.exe. В системе должен запущен один экземпляр services.exe из каталога system32.
* svchost.exe – главный процесс для служб, загружаемых из динамических библиотек. Некоторые компьютерные вирусы и маскируются под имя svchost.exe, помещая исполняемый файл в отличный от system32 каталог. Данный процесс запускается только от SYSTEM, LOCAL SERVICE или NETWORK SERVICE и не может быть запущен от имени пользователя.  
* lsass.exe - несет ответственность за обеспечение политики безопасности, проверку паролей, и создание маркеров доступа. Зачастую вредоносные программы также скрывается под именем, схожим с именем данного процесса, заменяя в своем названии первую строчную «L» на прописную «I», выглядящую похоже.
* winlogon.exe – компонент операционной системы Microsoft Windows, отвечающий за вход в систему. Как и для большинства других системных процессов ее исполняемый файл находится в каталоге system32.
* explorer.exe – также известен как Windows Explorer, он отвечает за взаимодействие с пользователем: графический интерфейс, папки, навигация. Данный процесс также имеет доступ к конфиденциальным материалам – открытым документам, учетным записям. Процесс запускается вместе с Windows Explorer и позволяет Вам использовать файловую систему компьютера.
* smss.exe – представляет подсистему менеджера сеансов. Данная подсистема является ответственной за запуск пользовательского сеанса. Этот процесс инициализируется системным потоком и ответствен за различные действия, включая запуск процессов Winlogon и Win32 (Csrss.exe) и установку системных переменных. Файл smss.exe расположен в каталоге c:\windows\System32. В случае обнаружения этого файла в любом другом каталоге стоит обратить особое внимание на данный объект, т.к. велика вероятность, что он вредоносный.
* csrss.exe – подсистема клиент/сервер времени выполнения, играет важную роль в создании и удалении процессов и потоков, поддерживает собственный список объектов, которые можно использовать для перекрестных ссылок с другими источниками данных. Запущено несколько процессов csrss.exe, поскольку каждая сессия создает выделенную копию. При анализе особое внимание следует обратить на название процесса, так как многие вредоносные программы используют названия легальных процессов для сокрытия своего присутствия на компьютере или слегка изменяют их, например csrsss.exe.

Также с помощью реализованного алгоритма удалось установить список файлов реестра (см. Табл. 5.2.), а именно имя файла реестра, физический адрес хайва, и удалось осуществить трансляцию индекса ячейки каждого хайва с последующей целью обхода узлов реестра. (//? обход не получается осуществить, не могу разобраться, что за странный указатель на subkeys, как лучше это описать?)

**Таблица 5.2.** Список найденных файлов реестра

|Имя файла реестра              |Физический адрес|
|-------------------------------|:---------------|
|Volume Information\Syscache.hve|9C98010         |
|\Microsoft\Windows\UsrClass.dat|13CD9010        |
|\??\C:\Users\ * \ntuser.dat    |16908010        |
|files\NetworkService\NTUSER.DAT|1A84D410        |
|rofiles\LocalService\NTUSER.DAT|1A9A8010        |
|\SystemRoot\System32\Config\SAM|1C813010        |
|emRoot\System32\Config\SECURITY|1FC5E010        |
|temRoot\System32\Config\DEFAULT|20543010        |
|emRoot\System32\Config\SOFTWARE|21620010        |
|Device\HarddiskVolume1\Boot\BCD|22018010        |
|NO NAME                        |274BC010        |
|NO NAME	                  |27534010        |
|System                         |275BF010        |

# Заключение

В данной работе были разработаны, реализованы и апробированы криминалистически правильные методы обработки процессов и данных реестра дампов оперативной памяти ОС Windows 7. В отличие от существующих методик и технологий имплементированные алгоритмы подходят для обработки любых форматов дампов физической памяти. 

В дальнейшем планируется создать автоматизированный программный комплекс, задача которого состоит в неинвазивном анализе динамики оперативной памяти гостевых операционных систем. Разработанный модуль, отвечающий за анализ дампов оперативной памяти, является частью данного комплекса.


# Литература

[1]	Федотов Н.Н. Форензика – компьютерная криминалистика. М.: Юридический мир, 2007. 432 с.

[2]	 Федеральный закон "О полиции" от 07.02.2011 №3-ФЗ, ст.11. //? как оформить?

[3]	Уголовно-Процессуальный кодекс Российской Федерации от 18.12.2001 № 174-ФЗ, ст.164. //? как оформить?

[4]	Hale Ligh M., Case A., Levy J., Walters A. The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory. Indianapolis: John Wiley & Sons, Inc., 2014. 866 p.

[5]	Carvey H. Windows Forensic Analysis DVD Toolkit 2E. Burlington, MA: Elsevier, Inc., 2009. 482 p.

[6]	Russinovich M., Solomon D., Ionescu A. Windows Internals, Part 2, Sixth Edition. Redmond, Washington: Microsoft Press, 2012. 645 p.

[7]	Intel 64 and IA-32 Architectures Software Developer’s Manual. Combined Volumes: 1, 2A, 2B, 2C, 3A, 3B, 3C. [Электронный ресурс]: URL: http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-manual-325462.html (дата обращения: 12.03.2015)

[8] Russinovich M., Solomon D., Ionescu A. Windows Internals, Part 1, Sixth Edition. Redmond, Washington: Microsoft Press, 2012. 726 p.

[9] Schuster A. Searching for processes and threads in Microsoft Windows memory dumps // Digital Investigation. 2006. Vol. 3. P.10-16.	

[10] Dolan-Gavitt B. Forensic analysis of the Windows registry in memory // Digital Investigation. 2008. Vol. 5. P.26-32.

[11] Вирт Н. Алгоритмы и структуры данных. Новая версия для Оберона. М.: ДМК Пресс, 2010. 272 с.

[12] Алгоритм Ахо-Корасик. [Электронный ресурс]: URL: http://e-maxx.ru/algo/aho_corasick (дата обращения: 12.03.2015)
