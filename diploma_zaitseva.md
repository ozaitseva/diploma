# Введение

## Актуальность

Наряду с появлением новых изобретений в сфере компьютерных и информационных технологий, появляются принципиально новые общественные отношения, которые и становятся предметом преступных посягательств. Почти каждый человек сегодня пользуется компьютером, платежными терминалами, мобильным телефоном и прочими современными технологиями, но вместе с этим и у злоумышленников появляются новые средства и орудия для совершения преступлений: эксплуатация уязвимостей серверов с публичными веб-сайтами, несанционированное проникновение в электронную почту, внедрение в инфраструктуру платежных систем и т.п. Например, даже кража или мелкое мошенничество часто совершаются сегодня при помощи сети Интернет. 

Наука, которая занимается раскрытием, расследованием и предотвращением такого рода преступлений – преступлений, связанных
с компьютерной информацией, – называется *компьютерной криминалистикой* или *компьютерной форензикой* (с английского computer forensics) [1]. Естественно, она включает в себя как методы сбора, обработки и анализа доказательств, представленной в виде компьютерной информации (так называемых цифровых доказательств), так и применяемый для этого программно-аппаратный инструментарий. 
Термин «форензика» произошел от латинского «foren», что значит «речь перед форумом», т.е. выступление перед судом,
судебные дебаты. В русский язык это слово пришло из английского. Термин «forensics» является сокращенной формой «forensic science», дословно «судебная наука», т.е. наука об исследовании доказательств – именно то, что в России именуется криминалистикой [1].
При заимствовании, слово «форензика» сузило свое значение и часто применяется в ИТ-контексте.

Компьютерная криминалистика ориентирована на решение следующих задач:

* Сбор и анализ цифровой информации, хранящейся в запоминающих устройствах компьютера.

В отличие от традиционных разделов криминалистики, таких как дактилоскопия, баллистика, которые развиваются уже давно,
компьютерная криминалистика – наука новая, которая родилась совсем недавно, и в России только недавно оформилась в полноценное направление криминалистической науки.
Опыт и инструментарий ее пока невелик, однако имеется большое количество предпосылок для бурного развития данной науки. ~~Необходимо создавать собственные программно-аппаратные решения для решения задач компьютерной криминалистики и заимствовать передовой опыт зарубежных стран.~~

Законодательство Российской Федерации нацелено на использование современных программных и аппаратных средств. Так, согласно
ст. 11 Федерального закона «О полиции» [2], «полиция в своей деятельности обязана использовать достижения науки и техники,
информационные системы, сети связи, а также современную информационно-телекоммуникационную инфраструктуру». В настоящее время
полиция использует средства аудио-, фото- и видеофиксации при проведении следственных действий и оперативно-розыскных мероприятий.
Согласно уголовно-процессуальному кодексу Российской Федерации при производстве следственных действий допускается применение
технических средств - п. 6 ст. 164 УПК [3] «при производстве следственных действий могут применяться технические средства
и способы обнаружения, фиксации и изъятия следов преступления и вещественных доказательств».

Нетрудно заметить, что в ближайшем будущем при раскрытии компьютерных преступлений невозможно будет обойтись без нового
современного программно-аппаратного оснащения, необходимого для исследования цифровых носителей информации.

Компьютерная криминалистика применяется в следующих сферах [1]:

* Раскрытие и расследование уголовных и гражданских преступлений, связанных с компьютерной информацией, которая может быть как объектом посягательства, так и орудием совершения преступления или доказательством;
* Расследования инцидентов информационной безопасности в компаниях, работающих с информацией, содержащей коммерческую тайну и иные конфиденциальные данные;
* Поиск, уничтожение, восстановление и защита компьютерной информации в военных и разведывательных задачах;
* Защита личной информации граждан, представленной в электронном виде.

Процесс, цель которого раскрыть совершенное компьютерное преступление, принято делить на 4 этапа [1]: 

1. Сбор: сбор информации и источников информации, а также использование специализированных программно-аппаратных средств для этого. При сборе необходимо оставить пометку с указанием источников и происхождения данных и объектов, также следует обеспечить сохранность, целостность (неизменность) и конфиденциальность данных.
2. Исследование: извлечение и обработка информации.
3. Анализ: собранная информация изучается и анализируется с целью поиска ответов на вопросы, которые стоят перед специалистом.
4. Представление: оформление результатов исследования и анализа в установленной законом и понятной неспециалистам форме.

Информация, представляющая интерес для эксперта, может быть различной по виду и содержанию: сетевые соединения, имена пользователей и пароли, удаленные файлы и многое другое. Данная информация хранится в различных подсистемах компьютера, поэтому существуют и различные методы, которые применяются для извлечения и анализа цифровых данных и ориентированные на:

* Снятие образов памяти и данных персистентных носителей данных, т.е. дисков (англ. acquisition);
* Извлечение (англ. memory acquisition) и анализ данных оперативной памяти (англ. memory analysis) и дисков (англ. data carving) [5].

В данной работе основное внимание уделяется развитию второго подхода, а именно методам сбора и анализа образов оперативной (физической) памяти.
Любая активно используемая информация, например, прошлые и текущие сетевые соединения, список запущенных процессов, имена пользователей и пароли, содержимое открытых окон ГИП, открытые ключи реестра, с помощью компьютерной программы или аппаратного устройства будет записываться в оперативную память системы, в то время пока они используются. Этот факт указывает на то, что криминалистически правильные методы извлечения и анализа данных энергозависимой памяти критически важны при проведении компьютерно-криминалистических исследований. Для извлечения содержимого физической памяти используются аппаратные и программные средства. К аппаратным методам относятся такие методы, как использование карты расширения Tribble, шины FireWire, а также аварийные дампы. Однако данные подходы имеют большое количество недостатков. Недостатком использования аппаратных карт является необходимость заранее скрыто установить Tribble на компьютере, который может быть подвержен вредоносной атаке; использование шины FireWire вызывает «синий экран смерти» (название сообщения о критической системной ошибке в операционных системах Microsoft Windows).
[4] Для операционных систем семейства Windows есть большое количество программных средств, которые снимают образ памяти
и осуществляют последующий анализ, например, Belkasoft Live RAM Capturer, Volatility Framework, MANDIANT Memoryze,
Guidance Softwate WinEn, Moonsools DumpIt, FTK Imager. Главные недостатки программных средств состоит в их инвазивности – модификации
памяти. 

## Цель работы

Исследовать методики обработки дампов физической памяти операционных систем семейства Windows NT в контексте создания криминалистического программного комплекса, интегрированного с платформами виртуализации и позволяющего производить неинвазивный анализ динамики оперативной памяти.

## Задачи

Для успешного достижения поставленной цели необходимо:

* Исследовать существующие методики анализа внутренней памяти;
* Изучить устройство внутренней памяти операционных систем семейства Windows;
* Сформулировать алгоритм поиска структур данных в образе физической памяти;
* Разработать инструмент для поиска структур данных в образе оперативной памяти и последующего ее анализа.

# Глава 1.

## Обзор существующих методик и технологий

На данный момент для извлечения и анализа данных физической памяти компьютеров, работающих под управлением
операционных систем Windows NT существует большое количество программно-аппаратных средств. 

К аппаратным средствам относятся:

1. Карты расширения Tribble

 Данный механизм может быть использован для копирования содержимого физической памяти на внешнее устройство.

 Достоинства:

 * легкодоступные;
 * не вводят никакого дополнительного программного обеспечения в систему, тем самым сводя к минимуму модификацию данных.

 Недостатки: 

 * оборудование должно быть установлено до происшествия/инцидента.

2. Шина FireWire

 Данное устройство обеспечивают извлечение данных физической памяти, используя прямой доступ к памяти (DMA, Direct Memory Access), то есть они могут получить доступ к системной памяти без прохода через центральный процессор. Отображение памяти выполняется
на аппаратном уровне, минуя основную операционную систему, что обеспечивает быстрый доступ к данным и быструю передачу данных.

 Достоинства:

 * во многие устройства, доступные сегодня, шина FireWire/IEEE 1394 встроена прямо в материнскую плату.

 Недостатки:

 * часть данных может быть пропущена;
 * данный способ вызывает «синий экран смерти» (название сообщения о критической системной ошибке в операционных системах
Microsoft Windows).

3. Аварийные дампы

 Данный способ позволяет получить не модифицированную копию содержимого оперативной памяти системы Windows с помощью
создания причины дампа. Когда происходит аварийный дамп, система замораживается и содержимое оперативной памяти записывается на диск. 
 Это сохраняет состояние системы и гарантирует, что никакие изменения не будут внесены в систему после того, как был вызван аварийный дамп.

 Достоинства:

 * технически точный метод создания образа содержимого оперативной памяти.

 Недостатки:

 * не все версии ОС Windows генерируют полные аварийные дампы по умолчанию;
 * изменение системы для приема последовательности нажатий клавиш, инициирующих создание дампа требует перезагрузки и должно быть сделано заранее.

К программным методам относятся такие утилиты, как Belkasoft Live RAM Caputer, MANDIANT Memoryze, HBGary, FTK Imager, 
Volatility Framework и др. Как было написано ранее, главных недостаток всех программных методов заключается в том, что данные инструменты должны иметь свой резидентный код в оперативный памяти, который в разной степени модифицирует ее. Также стоит отметить, что программные средства не являются легкодоступными и имеют высокую стоимость. 

## Настройка рабочего окружения

В качестве рабочей операционной системы использовался дистрибутив Ubuntu, основанный на Debian GNU/Linux. 
В настоящее время Ubuntu официально поддерживает только один гипервизор - QEMU-KVM. Для его эффективного использования 
процессор должен поддерживать технологию аппаратной виртуализации (Intel VT-x/AMD-V). Базовой операционной системой является 
Ubuntu 14.04.2 Server AMD64 (x86-64). Выбор 64-битной платформы объясняется наличием важных для нас возможностей:

* Выделением гостевым системам более 2 ГиБ оперативной памяти.
* Технология виртуализации, которая позволяет эмулировать различное аппаратное обеспечение, а также управлять ресурсами 
и изолировать ресурсы между несколькими запущенными гостевыми операционными системами.

В качестве гостевой системы была выбрана Microsoft Windows 7 Professional x64, как одна из наиболее популярных на данный момент операционных систем.

### Обзор устройства внутренней памяти Windows 7 на платформе x86-64

Для проведения анализа образа оперативной памяти сначала необходимо изучить, как устроена память конкретной операционной системы.
Ниже представлен краткий обзор устройства внутренней памяти Windows 7 на платформе x86-64.

#### Преобразование виртуального адреса в физический

Часть операционной системы, которая отвечает за управление памятью, называется менеджером или диспетчером памяти. Говоря о системе
управления памятью, используют понятия физической и виртуальной памяти. 

Под физической памятью подразумевается оперативная память, которая представляет упорядоченный набор однобайтовых ячеек, каждая из которых имеет свой уникальный адрес.
Совокупность адресов в физической памяти, используемых для идентификации хранимых в памяти данных, называется физическим адресным пространством. 
Виртуальная память - это абстрактное хранилище, используемое для хранения данных процессов, позволяющее программе «считать», что ей предоставлен неограниченный объем 
памяти и непрерывное адресное пространство памяти. Объем виртуальной памяти равен объему максимально адресуемой памяти. Виртуальное адресное пространство процесса в 
архитектуре x86-64 теоретически может составлять 16 экзабайт (2^64байт). Понятно, что у современных компьютеров нет необходимости поддерживать такой объем 
памяти, поэтому чтобы упростить архитектуру микросхем и уменьшить число издержек в нынешних процессорах x64 производства AMD и Intel реализовано только 256 Тбайт 
виртуального адресного пространства, то есть реализованы только младшие 48 разрядов 64-разрядного виртуального адресного пространства. Однако разрядность виртуального 
адреса все равно составляет 64 бита, тем самым занимая 8 байт в регистрах. В результате чего появилось требование, чтобы старшие 16 разрядов (48-63) имели значение 
равное старшему реализованному разряду (47). Адреса, удовлетворяющие данному требованию, называются «каноническими» и имеют следующие значения: 0x0000000000000000 - 0x00007FFFFFFFFFFF, а также 0xFFFF800000000000 -  0xFFFFFFFFFFFFFFFF [11].

Виртуальная память в операционной системе Windows имеет сегментно-страничную организацию. Отличительной чертой данной модели является то, что адресное пространство процесса представляется в виде набора сегментов переменного размера. Для удобства преобразования (трансляции) виртуального адреса в физический каждый сегмент делится на страницы - блоки фиксированного размера, при этом физическая память делится на блоки того же размера - страничные кадры (фреймы). 
Процессоры, на которых работает Windows, поддерживают страницы двух размеров — малые, размером 4 Кб, и большие, размером 2 Мб. [12] По умолчанию адресное 
пространство каждого процесса изолировано, то есть не может возникнуть такой ситуации, что данные двух разных процессов будут записаны в одну и ту же страницу 
физической памяти. За преобразование виртуального адреса в физический отвечают таблицы страниц, которые каждой виртуальной страницы ставит в соответствие страничный кадр. 
Возможны две схемы преобразования адреса для Windows на платформе x86: с расширением физических адресов (Physical Address Extension, PAE) и без него. Системы на платформе x86 без 
поддержки PAE для преобразования виртуальных адресов в физические используют двухуровневую структуру таблицы страниц, состоящую из каталога страниц (page directory, PD) и 
таблицы страниц (page table, PT). Виртуальный адрес представляется в виде двух полей: поля номера виртуальной страницы (virtual page number), который в свою очередь 
делится на два подполя: индекс каталога страниц (page directory index) и индекс таблицы страниц (page table index), и поля байтового смещения (byte offset). 
В данной работе будет рассмотрена архитектура x86-64, так как большинство современных процессоров поддерживает именно эту систему команд. 
Системы на платформе x86-64 для трансляции адресов используют схему, схожу со схемой с поддержкой PAE. 
Они используют четырехуровневую структуру таблицы страниц. 48-разрядный виртуальный адрес представляет собой совокупность 5 полей: 
селектора четвертого уровня отображения страницы (биты 47-39), селектор указателя каталога страниц (биты 38-30), селектор таблицы страниц (биты 29-21), 
селектор записи таблицы страниц (биты 20-12) и байтовое смещение (биты 11-0). Эти поля служат для локализации записей в соответствующих таблицах преобразования.[11]

![Виртуальный адрес на платформе x86-64] (https://github.com/ozaitseva/diploma/blob/master/images/virt_adr.jpg "Виртуальный адрес на платформе x86-64")

![Структуры преобразования адресов на платформе x86-64](https://github.com/ozaitseva/diploma/blob/master/images/transl_adr.jpg "Структуры преобразования адресов на платформе x86-64")

Записи (такие как PDPE, PDE, PTE и др) в нижеописанных таблицах преобразования представляют собой 8-байтные значения. Биты с номерами 12-39 образуют 
значения PFN (page frame number), которые указывают на физический адрес таблицы предыдущего уровня. Оставшиеся биты — это флаги, 
указывающие на состояние страниц.

![Аппаратная запись таблицы страниц на платформе x86-64](https://github.com/ozaitseva/diploma/blob/master/images/pte.jpg "Аппаратная запись таблицы страниц на платформе x86-64")

В поставленной в данной работе задаче необходимо восстановить виртуальное адресное пространство процесса, используя снятый образ физической памяти, 
то есть провести преобразования известных виртуальных адресов в соответствующие им физические, тем самым получив данные всех страниц виртуальной памяти 
из кадров (фреймов) оперативной памяти.

Преобразования физического адреса выполняется в несколько этапов:

Шаг 1: Найти физический адрес записи расширенного каталога страниц четвертого уровня, называемого таблицей отображения страниц четвертого уровня (page map level 4), который имеет следующую структуру: 

* Биты 51-12 совпадают со значениями битов 51-12 поля DTB,
* Биты 11-3 соответствуют битам 47-39 виртуального адреса,
* Биты 2-0 равны нулю.

Шаг 2: Найти физический адрес записи структуры третьего уровня, которая называется PDPT (page directory pointer table). Физический адрес имеет аналогичный предыдущей записи вид:

* Биты 51-12 из записи таблицы PML4,
*	Биты 11-3 соответствуют битам 38-30 виртуального адреса,
*	Биты 2-0 равны нулю.

Шаг 3: Найти значение PS-флага (бит 7) записи таблицы PDPT:

*	если флаг принимает значение 1, то данная запись ссылается на большую страницу, размером 1 ГиБ. Записав PFN-номер из данной записи в биты 51-30 и значение смещения 
из виртуального адреса в биты 29-0, получаем искомый соответствующий данному виртуальному физический адрес,
*	если флаг равен нулю, то переходим к шагу 4.

Шаг 4: Найти физический адрес записи каталога страниц второго уровня - таблицы PD (page directory). Структура соответствующего физического адреса:

*	Биты 51 — 12 соответствуют битам 51-12 записи таблицы PDPT,
*	Биты 11-3 равны битам 29-21 виртуального адреса,
*	Биты 2-0 имеют нулевое значение.

Шаг 5: Найти значение PS-флага записи таблицы PD:

*	если флаг равен 1, то PDE указывает на страницу, размер которой составляет 2 МиБ. В данном случае 
получаем физический адрес, у которого значения битов 51-21 хранятся в записи таблицы PDE, а значения 20-0  - из виртуального адреса,
*	В противном случае переходим к шагу 6.

Шаг 6: Найти физический адрес записи таблицы страниц (page table):

*	биты 51-12 физического адреса записи совпадают с 51-12 битами PDE,
*	биты 11-3  - биты 20-12 виртуального адреса,
*	биты 2-0 равны нулю.

Шаг 7: Найти физический адрес соответствующий данному виртуальному:

*	Биты 51-12 из PTE-записи,
*	Биты 11-0 — смещение из виртуального адреса.

Таким образом, после преобразования получаем физический адрес, соответствующий текущему виртуальному адресу. 

Если в PTE-записи бит достоверности (0 бит) принимает нулевое значение, то это значит, что в данный момент страница недоступна процессу,
то есть данная PTE-запись предоставляет недостоверную страницу.  При ссылке на такую страницу, диспетчер памяти выдает ошибку отсутствия страницы, 
блок управления память в свою очередь игнорирует все остальные биты PTE-записи, поэтому операционная система может использовать эти биты для хранения 
информации о странице, ставшей причиной выдачи ошибки.

Существует пять видов недостоверных PTE-записей: 

1. Файл подкачки (*Page File PTE*). Биты *V* (0), *P* (10), *U* (11) равны нулю. Искомая страница находится в файле подкачки. В данном случае биты 1-4 ссылаются 
на один из шестнадцати файлов подкачки, а биты 12-51 указывают на смещение в данном файле. Файлы подкачки используются для хранения страниц, которые еще 
могут понадобиться, но места для их хранения в оперативной памяти нет, поэтому они записываются на диск. Если минимальный и максимальный размер файлов подкачки, 
на которые указывает параметр реестра *HKLM\SYSTEM\CurrentControlSet\Control\SessionManager\MemoryMange-ment\PagingFiles*, равны нулю, то это указывает на то, 
что данный файлы управляются системой. Система выбирает размер данных файлов, исходя из объемов оперативной памяти. Смещение в файле подкачки никогда не бывает 
нулевым и не может полностью состоять из единиц, то есть первая и последняя страницы из файла подкачки никогда не используются для самой подкачки. 
Найдя данную запись, необходимо вернуть соответствующие данные из файла подкачки.

2. Заполнение нулями (*Demand Zero PTE*). Данная PTE-запись совпадает с предыдущим видом, но поле, отвечающее за смещение в файле подкачки,
и поле, ссылающееся на сам файл, полностью заполнены нулями. В данном случае обработчик ошибок выберет свободную страницу из списка страниц,
заполненных нулями, а в случае, если такой список пуст, то берет свободную страницу и заполняет ее нулями, если же и свободных страниц нет, то выбирает
одну из страниц, ожидающих использования, и заполняет ее нулями. Следовательно, получив данную запись, необходимо вернуть страницу, состоящую из нулей.

3. Переходное состояние (*Transition PTE*). Бит *U* (11) содержит единицу, биты *V* (0) и *P* (10) равны нулю. Искомая страница находится в списке ожидающих использования 
или измененных, но еще не записанных страниц. Именно поэтому страница запись данного вида обрабатывается как действительная.

4. Прототипная PTE-запись (*Prototype PTE*). Бит *P* (10) равен единице. Записи таблицы страниц такого вида используется для отображения страниц, которые используются 
несколькими процессами. Формат прототипных записей таблиц страниц аналогичен формату выше рассмотренных PTE-записей. Записи данного типа имеют собственную классификацию, 
в следствие чего их обработка рассмотрена ниже.

5. Неизвестная страница (*Zero PTE*). PTE-запись заполнена нулями. С помощью диспетчера управления ошибок и VAD-дескрипторов можно узнать, был ли данный виртуальный адрес 
подтвержден. Больше никакой информации о данной странице получить невозможно.

Если бит достоверности PML4-записи, PDPT-записи или PDE равен нулю, то есть данные страницы являются недействительные, то их следует обрабатывать также, 
как *Page File PTE* или *Transition PTE*.

Особое внимание стоит уделить обработке прототипных записей. Страницы, на которые ссылаются данные записи, не используются в процессе 
преобразования адресов напрямую, а лишь являются промежуточным уровнем поиска номера страничного блока. Адрес прототипной страницы получается следующим образом:

*address = (PTE >> 16) + 0xFFFF000000000000*.

Найденная страница может находить в одном из шести состояний[13]:
 
* Активна/достоверна. Бит *V* (0) равен 1. Данная страница находится в физической памяти и обрабатывается как действительная. 
* Переходное состояние. Бит *U* (11) равен 1. Искомая страница находится в оперативной памяти и ожидает использования, либо была изменена.
При обработке необходимо вернуть страницу из памяти.
* Изменение без записи. Бит *D* (6) равен 1. Искомая страница была изменена, но не записана.  
* Заполнение нулями. Биты *P* (10), *U* (11) равны 0, а также поле, отвечающее за смещение в файле подкачки, и поле, ссылающееся на сам файл, 
имеют нулевые значения. В качестве искомой должна быть предоставлена страница, заполненная нулями.
* Страничный файл. Биты *P* (10), *U* (11) равны 0. Необходимо вернуть страницу из файла подкачки. 
* Отображаемый файл. Бит *P* (10) равен 1. Искомая страница находится в отображаемом файле. 

#### Процессы и потоки

Каждый процесс ОС Windows представлен структурой *\_EPROCESS*. Данная структура содержит атрибуты, описывающие процесс, а также другие связанные с ним данные (например, структуру *\_ ETHREAD*, описывающую потоки процесса). Структуры *\_EPROCESS* располагаются в адресном пространстве ядра ОС.
Первым элементом структуры процесса является блок управления процессом, представленный структурой *\_KPROCESS*, также находящийся в пространстве ядра. Структуры *\_KPROCESS* и *\_KTHREAD* начинаются с субструктуры, известной как *\_DISPATCHER\_HEADER*. В ней содержатся поля *Type* и *Size*, определяющие тип и размер объекта соответственно, которые принимают одинаковые значения для всех процессов конкретной операционной системы (см. табл. 1).

| Версия Windows | Байтовый паттерн    |
|----------------|:-------------------:|
| XP x86         | 0x03 0x00 0x1B 0x00 |
| 2003 x86       | 0x03 0x00 0x1E 0x00 |
| 2003 x86-64    | 0x03 0x00 0x2E 0x00 |
| Vista x86      | 0x03 0x00 0x20 0x00 |
| Vista x86-64   | 0x03 0x00 0x30 0x00 |
| 7 x86          | 0x03 0x00 0x26 0x00 |
| 7 x86-64       | 0x03 0x00 0x58 0x00 |

**Таблица 1.** Байтовые паттерны для поиска структуры *\_DISPATCHER\_HEADER* для разных версий Windows.

Найдя соответствующие байтовые паттерны в адресном пространстве ядра дампа памяти, можно найти кандидаты на структуру *\_EPROCESS*.
Среди кандидатов могут оказаться не интересующие нас байтовые последовательности, которые, например, находятся в адресном пространстве пользователя,
поэтому необходимо проводить проверку. Именно, следует проверять, что последующий и предыдущий потоки процесса находятся в виртуальном адресном пространстве ядра:

* *ThreadListHead.Flink >= 0xFFFF800000000000*,
* *ThreadListHead.Blink >= 0xFFFF800000000000*.

Проверив данное условие, мы откинем процессы-кандидаты, которые находятся в адресном пространстве пользователя. 
Также исключить некорректные кандидаты можно с помощью условия, наложенного на значение управляющего регистра *CR3*, а, следовательно, 
и на значение поля *DirectoryTableBase* – биты 63-40 должны быть нулями.
Найдя структуру процесса, по значению поля DirectoryTableBase, хранящегося в структуре *\_KPROCESS*, можно получить физический адрес таблицы 
преобразования четвертого уровня PML4, а по значениям полей *ThreadListHead.Flink* и *ThreadListHead.Blink* виртуальные адреса последующего и предыдущего потоков соответственно.

#### Анализ реестра Windows 7x64 

Реестр в Windows - иерархически построенная база данных параметров и настроек в большинстве операционных систем Microsoft Windows. Он используется приложениями 
операционной системы для хранения всевозможной информации, начиная от простых конфигурационных данных и заканчивая конфиденциальными данными, такими как пароли 
учетных записей и ключами. Реестр может быть важным источником доказательств при проведении компьютерно-криминалистических исследований. Он содержит такую информацию, 
как недавно запущенные программы, журнал недавно подключенных устройств, сетевые соединения.

Внутреннее устройство реестра схоже с устройством дискового тома. Разделы реестра — это аналог каталогов диска, а параметры можно сравнить с файлами на диске. 
Раздел реестра состоит из подразделов или из параметров, в которых хранятся сами данные. Самые верхние разделы считаются корневыми. 
На диске реестр представлен набором файлов, которые носят название хайвы (англ. hive). Каждый хайв содержит дерево реестра, у которого есть раздел, 
служащий ему корнем или отправной точкой дерева. Подразделы и их параметры находятся ниже корня. Диспетчер конфигурации делит хайв на логические блоки также, как 
файловая система делит диск на кластеры. По определению, размер блока реестра составляет 4096 байт (4 Кб). Хайв хранит данные в контейнерах, которые называются ячейки. 
В ячейке хранятся разделы, параметры, список подразделов и параметров раздела. Если хайв должен быть расширен в следствие прибавления новой ячейки, создается единичный 
блок — приемник (англ. bin). За смещение ячейки в файле хайва отвечает индекс ячейки (за вычетом базового блока). Местонахождение ячейки в памяти может быть вычислено 
путем прибавления индекса ячейки к базе образа хайва. 

Каждый хайв в ОС Windows представлен структурой *\_CMHIVE*. В структуре *\_CMHIVE* содержится метаданные о хайве, такие как полный путь, число открытых дискрипторов, и 
указатели на другие хайвы (структура *\_LIST\_ENTRY*). Данная структура начинается с субструктуры *\_HHIVE*, в которой содержится виртуальный адрес базового блока хайва, 
представленного структурой *\_HBASE_BLOCK*. 

```
typedef struct _CMHIVE {
+0x000 struct _HHIVE Hive{
+0x000 ULONG32 Signature;
...
+0x050 struct _HBASE_BLOCK* BaseBlock;
...
+0x0A8 struct _DUAL Storage[2];
}                                 
...                     
+0x5D8 struct _LIST_ENTRY HiveList;                        
...             
}
```

Поиск хайвов в физической памяти осуществляется в два этапа.

**Шаг 1**: сканируем физическую память с целью поиска структуры *\_CMHIVE*. Это сделать достаточно легко, так как подструктура данной структуры  -  *\_HHIVE* начинается с постоянного значения поля *Signature* — *0xBEE0BEE0*.

**Шаг2**: проверяем на корректность найденные структуры. Корректные структуры должны иметь pool tag *«CM10»*.

Данных показателей достаточно, чтобы найти действительные структуры *\_HHVE* в Windows 7. Найдя соответствующие структуры, с помощью полей *HiveList.Flink* и *HiveList.Blink* 
можно получить виртуальные адреса последующего и предыдущего хайвов соответственно, а с помощью поля *BaseBlock* - виртуальный адрес базового блока. Далее необходимо преобразовать 
данные адреса в физические, используя значение *DirectoryTableBase* процесса *System*.

Основной блок хайва, представленный структурой *\_HBASE\_BLOCK* также имеет свою константную сигнатуру - *regf* или *0x66676572*. В данной структуре хранится с
ледующая информация: имя файла, путь к файлу, временная отметка и другие системные файлы. Имя файла может содержать максимум 32 символа. 
Известно, что каждый хайв содержит набор hive bin (*\_HBIN*). В каждой такой структуре имеется ссылка на последующую такую же структуру. 
Данная структура также имеет константную сигнатуру - *hbin*.
В следствие того, что хайв может расширяться, т.е. добавляются новые ячейки, данные хайва хранятся в памяти непоследовательно. 
Для работы с непоследовательными адресами памяти, диспетчер конфигурации использует метод, схожий с тем, что используется диспетчером памяти Windows для 
отображения адресов виртуальной памяти в физические адреса. Для отображения ячеек индекс ячейки делится на три поля:
индекс в каталоге отображения ячеек – биты 1-10, 
индекс в таблице отображения ячеек – биты 11-19 и смещение в карте ячеек – биты 20-31. Бит 0 является флагом, указывающим, где хранятся данные хайва – в основной или в оперативной памяти. 
Каталог отображения ячеек содержит 1024 записи, каждая из которых ссылается на таблицу отображения ячеек, 
содержащую 512 записей отображений. Виртуальный адрес, указывающий на массив виртуальных адресов каталогов отображения 
ячеек хранится в подструктуре структуры *\_HHIVE* - *Storage[2]* в поле *Map*.

![Трансляция индекса ячейки в памяти](https://github.com/ozaitseva/diploma/blob/master/images/cell_index_transl.jpg "Трансляция индекса ячейки в памяти")

Найденный посредством трансляции виртуальный адрес указывает на структуру _HMAP_ENTRY, которая содержит в себе:

```
typedef struct _HMAP_ENTRY {
0x000     UINT64       BlockAddress;
0x008     UINT64       BinAddress;
…
            }

```

Поле *BlockAddress* содержит виртуальный адрес начала структуры *\_HBIN*. Таким образом, добавив к данному адресу смещение (последние 12 бит), получим адрес, ссылающийся на необходимые нам данные.

### Обзор алгоритмов поиска подстроки в строке

Одной из подзадач данной работы является поиск байтового паттерна в дампе физической памяти, т.е. другими словами, поиск конкретной подстроки в строке. На сегодняшний день существует огромное разнообразие алгоритмов поиска подстроки. К таким относятся такие алгоритмы, как: алгоритм Бойера-Мура-Хорспула, автоматный алгоритм Ахо-Корасик, алгоритм Кнута-Морриса-Пратта и др. 

####Алгоритм Бойера-Мура-Хорспула

Алгоритм Бойера-Мура-Хорспула является упрощением алгоритма Бойера-Мура. Процедура алгоритма является очень простой. На первом шаге для каждого символа строится таблица смещений. Далее совмещается начало текста и искомого шаблона с целью сравнения. Если символы шаблона полностью совпали с символами строки, то поставленная задача решена и необходимая подстрока найдена. В противном случае шаблон сдвигается на определенное количество символов вправо. Это количество выбирается по следующему правилу: берется символ строки, оказавшийся над последним символом шаблона, - стоп-символ. Сдвигаем шаблон так, чтобы под стоп-символом оказался такой же символ шаблона. Если стоп-символа в шаблоне нет, шаблон смещается за этот стоп-символ. Например,

![Пример сдвига шаблона](https://github.com/ozaitseva/diploma/blob/master/images/patt_ex_bmh.jpg "Пример сдвига шаблона")

Данное правило реализуется посредством таблицы смещений, в которой каждому символу ставится в соответствие величина, равная разности длины шаблона и порядкового номера символа (если символ повторяется, то берется самое правое вхождение).
Алгоритм продолжается до тех пор, пока шаблон полностью не совпадет с подстрокой или пока не будет достигнут конец строки.

Данный алгоритм прост в реализации и является достаточно быстрым для поиска одного конкретного шаблона в строке, однако его производительность теряется при одновременном поиске нескольких подстрок.

#### Алгоритм Кнута-Морриса-Пратта

Алгоритм Кнута-Морриса-Пратта является одним из первых алгоритмов с линейной оценкой в худшем случае. Прежде, чем рассматривать алгоритм, необходимо дать определение понятию префикс-функции от строки.

*Префикс-функция от строки* – это длина наибольшего префикса строки, который одновременно является ее суффиксом, другими словами, это максимальная длина начала строки, которая в то же время является ее концом. Как и в классическом алгоритме поиска подстроки, шаблон сравнивается со строкой слева направо. Однако особенностью данного алгоритма является то, что при помощи префикс-функции можно избежать ненужных сдвигов.

Пусть шаблон *p[0,…,m-1]* наложен на строку *s[0,…,n-1]*, в которой ведется поиск. Рассмотрим сравнение строк на позиции *i*, т.е. шаблона *p[0,…,m-1]* с частью строки *s[i,i+m-1]*. Предположим, что первое несовпадение произошло между *s[i+j]* и *p[j]*, *1<j<m*, и *π[j]* – значение префикс-функции от строки *s[0,…,n-1]* для индекса *j*. Тогда сравнение можно возобновить с места *s[i+j]* и *p[π[j]]*, исключив бесполезные сдвиги.

Время работы такого алгоритма линейно зависит от объема входных данных.

#### Алгоритм Ахо-Корасик

Алгоритм Ахо-Корасик решает задачу эффективного поиска вхождений всех поступивших на вход шаблонов в заданную строку. Отличительной особенностью данного алгоритма является то, что для решения поставленной задачи в нем используется структура данных – бор, по которой строится конечный детерминированный автомат. 

Бор — это дерево, в котором каждая вершина обозначает какую-то строку, корень – это нулевая строка. На ребрах дерева расположен один символ, следовательно, пройдя по всем ребрам из корня в какую-либо вершину и конкатенируя символы ребер, мы получим строку, соответствующую данной вершине. Каждой вершине бора соответствует только одна строка.  

Как было сказано выше, в данном алгоритме необходимо построить конечный детерминированный автомат - такой автомат, в котором нет дуг, не содержащих ни одного символа, и из любого состояния по любому символу возможен переход в точности в одно состояние. Состояние автомата — это какая-то вершина бора. Для перехода автомата из одного состояния в другое используются следующие параметры: текущая вершина v и символ ch. Если из текущей вершины можно перейти по ребру c символом ch, то переходим по нему, иначе переходим по суффиксной ссылке и повторяем процедуру, начиная с новой вершины. 

Суффиксная ссылка вершины v - это указатель на вершину u, такую что строка u — наибольший собственный суффикс строки v, или, если такой вершины в боре нет, то указатель на корень. Для получения суффиксной ссылки вершины v необходимо перейти к ее родителю, пройти по суффиксной ссылке родителя и запустить переход из текущей вершины по символу, который указан на ребре родитель-v. Полученная вершина и есть суффикная ссылка вершины v.

Данный алгоритм показывает хорошие результаты в случае, когда нужно искать одновременно несколько постоянных шаблонов.

# Литература:

[1] Федотов Н.Н., Форензика — компьютерная криминалистика, издательство, стр. 10 - 36. 

[2] Федеральный закон "О полиции" от 07.02.2011 №3-ФЗ, ст.11.

[3] Уголовно-Процессуальный кодекс Российской Федерации от 18.12.2001 № 174-ФЗ, ст.164.

[4] Carvey Harlan, Windows Forensic Analysis DVD Toolkit, Chapter 3. 

[5] Michael Hale Ligh, Andrew Case, Jamie Levy, AAron Walters, The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory, P.69.

[6]  <http://help.ubuntu.ru/wiki/kvm>

[7]  <http://habrahabr.ru/post/170259/>

[8] <https://tails.boum.org/contribute/release_process/test/erase_memory_on_shutdown/qemu_pmemsave/>

[9] <http://stackoverflow.com/questions/25479873/how-to-enable-qemu-monitor-console-in-virtual-machine-manager>

[10] <http://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Administration_Guide/sect-vish-dump.html>

[11] Russinovich M., Solomon D., Windows Internals, Fifth Edition ("Внутреннее устройство Windows, часть вторая, шестое издание"), p. 240-271. Microsoft Press, 2014.

[12] Коньков К.А., Основы организации операционных систем Microsoft Windows, Лекция 9.

[13] Russinovich M., Solomon D., Windows Internals, Fifth Edition ("Внутреннее устройство Windows, часть вторая, шестое издание"), p. 312-314. Microsoft Press, 2014.
