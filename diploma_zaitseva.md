#Введение

##Актуальность

Наряду с появлением новых изобретений в сфере компьютерных и информационных технологий, появляются принципиально новые общественные 
отношения, которые и становятся предметом преступных посягательств. Почти каждый человек сегодня пользуется компьютером, платежными 
терминалами, мобильными телефонами и прочими современными технологиями, но вместе с этим и у преступников появляются новые технологии
и новые орудия преступления: веб-сайт, электронная почта, платежная система. Например, даже кража, мелкое мошенничество совершаются
при помощи сети Интернет. 

Наука, которая занимается раскрытием, расследованием и предотвращением такого рода преступлений – преступлений, связанных
с компьютерной информацией, – называется компьютерная криминалистика или форензика [1] (с английского forensics). Естественно,
она включает в себя как методы сбора, обработки и анализа доказательств, представленной в виде компьютерной информации (так
называемых цифровых доказательств), так и применяемые для этого программно-аппаратный инструментарий. 
Термин «форензика» произошел от латинского «foren», что значит «речь перед форумом», т.е. выступление перед судом,
судебные дебаты. В русский язык это слово пришло из английского. Термин «forensics» является сокращенной формой «forensic science»,
дословно «судебная наука», т.е. наука об исследовании доказательств – именно то, что в русском именуется криминалистикой [1].
При заимствовании слово сузило свое значение.

Компьютерная криминалистика ориентирована на решение следующих задач:

* сбор и анализ цифровой информации, хранящейся в запоминающих устройствах компьютера.

В отличие от традиционных разделов криминалистики, таких как дактилоскопия, баллистика, которые развиваются уже давно,
компьютерная криминалистика – наука новая, которая родилась совсем недавно, и в России только начала набирать обороты.
Опыт и инструментарий ее пока невелик, однако имеется большое количество предпосылок для развития данной науки. Необходимо
создавать собственные программно-аппаратные решения для решения задач компьютерной криминалистики и заимствовать передовой
опыт зарубежных стран.

Законодательство Российской Федерации нацелено на использование современных программных и аппаратных средств. Так, согласно
ст. 11 Федерального закона «О полиции» [2], «полиция в своей деятельности обязана использовать достижения науки и техники,
информационные системы, сети связи, а также современную информационно-телекоммуникационную инфраструктуру». В настоящее время
полиция использует средства аудио-, фото- и видеофиксации при проведении следственных действий и оперативно-розыскных мероприятий.
Согласно уголовно-процессуальному кодексу Российской Федерации при производстве следственных действий допускается применение
технических средств - п. 6 ст. 164 УПК [3] «при производстве следственных действий могут применяться технические средства
и способы обнаружения, фиксации и изъятия следов преступления и вещественных доказательств».

Нетрудно заметить, что в ближайшем будущем при раскрытии компьютерных преступлений невозможно будет обойтись без нового
современного программно-аппаратного оснащения, необходимого для исследования цифровых носителей информации.

Компьютерная криминалистика применяется в следующих сферах [1]:

* раскрытие и расследование уголовных и гражданских преступлений, связанных с компьютерной информацией, которая может быть как объектом посягательства, так и орудием совершения преступления или доказательством;
* расследования инцидентов информационной безопасности в компаниях, работающих с информацией, содержащей коммерческую тайну и иные конфиденциальные данные;
* поиск, уничтожение, восстановление и защита компьютерной информации в военных и разведывательных задачах;
* защита личной информации граждан, представленной в электронном виде.

Процесс, цель которого раскрыть совершенное компьютерное преступление, принято делить на 4 этапа [1]: 

1. Сбор: сбор информации и источников информации, а также использование специализированных программно-аппаратных средств для этого. При сборе необходимо оставить пометку с указанием источников и происхождения данных и объектов, также следует обеспечить сохранность, целостность (неизменность) и конфиденциальность данных.
2. Исследование: извлечение и обработка информации.
3. Анализ: собранная информация изучается и анализируется с целью поиска ответов на вопросы, которые стоят перед специалистом.
4. Представление: оформление результатов исследования и анализа в установленной законом и понятной неспециалистам форме.

Информация, представляющая интерес для эксперта, может быть различной по виду и содержанию: сетевые соединения, имена пользователей
и пароли, удаленные файлы и многое другое. Данная информация хранится в разных местах компьютера, поэтому существуют и различные методы,
которые применяются для извлечения и анализа данных:

* метод, ориентированный на снятие (англ. acquisition) образа памяти и анализ (англ. data carving) данных жесткого диска;
* извлечение (англ. memory acquisition) и анализ (англ. memory analysis) данных оперативной памяти [5].

В данной работе основное внимание уделяется развитию второго подхода, а именно методам сбора и анализа образов оперативной памяти.
Любая активно используемая информация, например, прошлые и текущие сетевые соединения, список запущенных процессов, имена пользователей
и пароли, содержимое открытого окна, открытые ключи реестра, с помощью компьютерной программы или аппаратного устройства будет записываться в оперативную память системы, в то время пока они используются. Этот факт указывает на то, что криминалистически правильные методы извлечения и анализа данных энергозависимой памяти критически важны при проведении компьютерно-криминалистических исследований. Для извлечения содержимого физической памяти используются аппаратные и программные средства. К аппаратным методам относятся такие методы, как использование карты расширения Tribble, шины FireWire, а также аварийные дампы. Однако данные подходы имеют большое количество недостатков. Недостатком использования аппаратных карт является необходимость заранее скрыто установить Tribble на компьютере, который может быть подвержен вредоносной атаке; использование шины FireWire вызывает «синий экран смерти» (название сообщения о критической системной ошибке в операционных системах Microsoft Windows).
[4] Для операционных систем семейства Windows есть большое количество программных средств, которые снимают образ памяти
и осуществляют последующий анализ, например, Belkasoft Live RAM Capturer, Volatility Framework, MANDIANT Memoryze,
Guidance Softwate WinEn, Moonsools DumpIt, FTK Imager. Главные недостатки программных средств состоит в их инвазивности – модификации
памяти. 

##Цель работы

Исследовать методики обработки дампов физической памяти операционных систем семейства Windows NT
в контексте создания криминалистического программного комплекса, интегрированного с платформами виртуализации
и позволяющего производить неинвазивный анализ динамики оперативной памяти.

##Задачи

Для успешного достижения поставленной цели необходимо:

* исследовать существующие методики анализа внутренней памяти;
* изучить устройство внутренней памяти операционных систем семейства Windows;
* сформулировать алгоритм поиска структур данных в образе физической памяти;
* разработать инструмент для поиска структур данных в образе оперативной памяти и последующего ее анализа.

#Глава 1.

##Обзор существующих методик и технологий

На данный момент для извлечения и анализа данных физической памяти компьютеров, работающих под управлением
операционных систем Windows NT существует большое количество программно-аппаратных средств. 

К аппаратным средствам относятся:

1. Карты расширения Tribble

Данный механизм может быть использован для копирования содержимого физической памяти на внешнее устройство.

Достоинства:

* легкодоступные;
* не вводят никакого дополнительного программного обеспечения в систему, тем самым сводя к минимуму модификацию данных.

Недостатки: 

* оборудование должно быть установлено до происшествия.

2. Шина FireWire

Данное устройство обеспечивают извлечение данных физической памяти, используя прямой доступ к памяти (DMA, Direct Memory Access),
то есть они могут получить доступ к системной памяти без прохода через центральный процессор. Отображение памяти выполняется
на аппаратном уровне, минуя основную операционную систему, что обеспечивает быстрый доступ к данным и быструю передачу данных.

Достоинства:

* во многие устройства, доступные сегодня, шина FireWire/IEEE 1394 встроена прямо в материнскую плату.

Недостатки:

* часть данных может быть пропущена;
* данный способ вызывает «синий экран смерти» (название сообщения о критической системной ошибке в операционных системах
Microsoft Windows).

3. Аварийные дампы

Данный способ позволяет получить не модифицированную копию содержимого оперативной памяти системы Windows с помощью
создания причины дампа. Когда происходит аварийный дамп, система замораживается и содержимое оперативной памяти записывается на диск. 
Это сохраняет состояние системы и гарантирует, что никакие изменения не будут внесены в систему после того, как был вызван аварийный дамп.

Достоинства:

* технически точный метод создания образа содержимого оперативной памяти.

Недостатки:

* некоторые системы Windows не генерируют полные аварийные дампы по умолчанию;
* изменение системы для приема последовательности нажатий клавиш для создания дампа требует перезагрузки и должно быть сделано заранее.

К программным методам относятся такие утилиты, как Belkasoft Live RAM Caputer, MANDIANT Memoryze, HBGary, FTK Imager, 
Volatility Framework и др. Как было написано ранее, главных недостаток всех программных методов заключается в том, что данные 
инструменты должны иметь свой резидентный код в оперативный памяти, который в разной степени модифицирует ее. Также стоит отметить, 
что программные средства являются труднодоступными и имеют высокую стоимость. 

##Настройка рабочего окружения

В качестве рабочей операционной системы использовался дистрибутив Ubuntu, основанный на Debian GNU/Linux. 
В настоящее время Ubuntu официально поддерживает только один гипервизор - Qemu-KVM. Для его эффективного использования 
процессор должен поддерживать технологию виртуализации (Intel VT-x/AMD-V). Базовой операционной системой является 
Ubuntu 14.04.2 Server AMD64 (x86-64). Выбор 64-битной платформы объясняется наличием важных для нас возможностей:

* Выделением гостевым системам более 2 ГиБ оперативной памяти.
* Технология виртуализации, которая позволяет эмулировать различное аппаратное обеспечение, а также управлять ресурсами 
и изолировать ресурсы между несколькими запущенными гостевыми операционными системами.

Для работы гипервизора на хост-систему был установлен базовый набор пакетов: `qemu-kvm`, `ubuntu-vm-builder`, `virtinst`,
а также библиотека `libvirt`.
В качестве хостовой системы была выбрана Windows 7 Professional x64, как наиболее популярная на данный момент операционная система.

##Операции с гостевой виртуальной машиной (**Надо ли?**)

###Снятие образа физической памяти

Для создания образа (дампа) физической памяти воспользуемся утилитой `pmemsave` из пакета `qemu-system`. 
Она имеет следующий формат аргументов [8]:

        pmemsave <start_address> <length> <file_name>

_NB: Максимальный размер одного дампа составляет 4 ГиБ._
        
Также получить образ физической памяти и регистров запущенной виртуальной машины можно с помощью команды [10]: 

        virsh dump <vm_name> <file_name> --live --memory-only

## Создание снэпшота диска

Сделать снэпшот диска можно с помощью библиотеки `libvirt`:

        virsh snapshot-create-as <vm_name> <snapshot_name> <snapshot description string> --disk-only --atomic

Для того, чтобы посмотреть список снэпшотов интересующей виртуальной машины нужно воспользоваться командой:

        virsh snapshot-list <vm_name>

###Обзор устройства внутренней памяти Windows 7 на платформе x86-64

Для проведения анализа образа оперативной памяти сначала необходимо изучить, как устроена память конкретной операционной системы.
Ниже представлен краткий обзор устройства внутренней памяти Windows 7 на платформе x86-64.

####Процессы и потоки

Каждый процесс ОС Windows представлен структурой *\_EPROCESS*. 
Данная структура содержит атрибуты, описывающие процесс, а также другие связанные с ним данные 
(например, структуру *\_ ETHREAD*, описывающую потоки процессов). Структуры *\_EPROCESS* располагаются в адресном пространстве ядра. 
Первым элементом структуры процесса является блок управления процессом, представленный структурой *\_KPROCESS*, также находящийся в 
пространстве ядра. Структуры *\_KPROCESS* и *\_KTHREAD* начинаются с субструктуры, известной как *\_DISPATCHER\_HEADER*. В ней содержатся поля *Type* и *Size*,
определяющие тип и размер объекта соответственно, которые принимают одинаковые значения для всех процессов конкретной операционной системы (см. табл. 1).

| Версия Windows | Байтовый паттерн    |
|----------------|:-------------------:|
| XP x86         | 0x03 0x00 0x1B 0x00 |
| 2003 x86       | 0x03 0x00 0x1E 0x00 |
| 2003 x86-64    | 0x03 0x00 0x2E 0x00 |
| Vista x86      | 0x03 0x00 0x20 0x00 |
| Vista x86-64   | 0x03 0x00 0x30 0x00 |
| 7 x86          | 0x03 0x00 0x26 0x00 |
| 7 x86-64       | 0x03 0x00 0x58 0x00 |

**Таблица 1.** Байтовые паттерны для поиска структуры *\_DISPATCHER\_HEADER* для разных версий Windows.

Найдя соответствующие байтовые паттерны в адресном пространстве ядра дампа памяти, можно найти кандидаты на структуру *\_EPROCESS*.
Среди кандидатов могут оказаться не интересующие нас байтовые последовательности, которые, например, находятся в адресном пространстве пользователя,
поэтому необходимо проводить проверку. Именно, следует проверять, что последующий и предыдущий потоки процесса находятся в виртуальном адресном пространстве ядра:

* *ThreadListHead.Flink >= 0xFFFF800000000000*,
* *ThreadListHead.Blink >= 0xFFFF800000000000*.

Проверив данное условие, мы откинем процессы-кандидаты, которые находятся в адресном пространстве пользователя. 
Также исключить некорректные кандидаты можно с помощью условия, наложенного на значение управляющего регистра *CR3*, а, следовательно, 
и на значение поля *DirectoryTableBase* – биты 63-40 должны быть нулями.
Найдя структуру процесса, по значению поля DirectoryTableBase, хранящегося в структуре *\_KPROCESS*, можно получить физический адрес таблицы 
преобразования четвертого уровня PML4, а по значениям полей *ThreadListHead.Flink* и *ThreadListHead.Blink* виртуальные адреса последующего и предыдущего потоков соответственно.

####Преобразование виртуального адреса в физический

Часть операционной системы, которая отвечает за управление памятью, называется менеджером или диспетчером памяти. Говоря о системе
управления памятью, используют понятия физической и виртуальной памяти. 

Под физической памятью подразумевается оперативная память, которая представляет упорядоченный набор однобайтовых ячеек, каждая из которых имеет свой уникальный адрес.
Совокупность адресов в физической памяти, используемых для идентификации хранимых в памяти данных, называется физическим адресным пространством. 
Виртуальная память - это абстрактное хранилище, используемое для хранения данных процессов, позволяющее программе «считать», что ей предоставлен неограниченный объем 
памяти и непрерывное адресное пространство памяти. Объем виртуальной памяти равен объему максимально адресуемой памяти. Виртуальное адресное пространство процесса в 
архитектуре x86-64 теоретически может составлять 16 экзабайт (2^64байт). Понятно, что у современных компьютеров нет необходимости поддерживать такой объем 
памяти, поэтому чтобы упростить архитектуру микросхем и уменьшить число издержек в нынешних процессорах x64 производства AMD и Intel реализовано только 256 Тбайт 
виртуального адресного пространства, то есть реализованы только младшие 48 разрядов 64-разрядного виртуального адресного пространства. Однако разрядность виртуального 
адреса все равно составляет 64 бита, тем самым занимая 8 байт в регистрах. В результате чего появилось требование, чтобы старшие 16 разрядов (48-63) имели значение 
равное старшему реализованному разряду (47). Адреса, удовлетворяющие данному требованию, называются «каноническими» и имеют следующие значения: 0x0000000000000000 - 0x00007FFFFFFFFFFF, 
а также 0xFFFF800000000000 -  0xFFFFFFFFFFFFFFFF. [11]

Виртуальная память в операционной системе Windows имеет сегментно-страничную организацию. Отличительной чертой данной модели является то, что адресное 
пространство процесса представляется в виде набора сегментов переменного размера. Для удобства преобразования (трансляции) виртуального адреса в физический 
каждый сегмент делится на страницы - блоки фиксированного размера, при этом физическая память делится на блоки того же размера - страничные кадры (фреймы). 
Процессоры, на которых работает Windows, поддерживают страницы двух размеров — малые, размером 4 Кб, и большие, размером 2 Мб. [12] По умолчанию адресное 
пространство каждого процесса изолировано, то есть не может возникнуть такой ситуации, что данные двух разных процессов будут записаны в одну и ту же страницу 
физической памяти. За преобразование виртуального адреса в физический отвечают таблицы страниц, которые каждой виртуальной страницы ставит в соответствие страничный кадр. 
Возможны две схемы преобразования адреса для Windows на платформе x86: с расширением физических адресов (Physical Address Extension, PAE) и без него. Системы на платформе x86 без 
поддержки PAE для преобразования виртуальных адресов в физические используют двухуровневую структуру таблицы страниц, состоящую из каталога страниц (page directory, PD) и 
таблицы страниц (page table, PT). Виртуальный адрес представляется в виде двух полей: поля номера виртуальной страницы (virtual page number), который в свою очередь 
делится на два подполя: индекс каталога страниц (page directory index) и индекс таблицы страниц (page table index), и поля байтового смещения (byte offset). 
В данной работе будет рассмотрена архитектура x86-64, так как большинство современных процессоров поддерживает именно эту систему команд. 
Системы на платформе x86-64 для трансляции адресов используют схему, схожу со схемой с поддержкой PAE. 
Они используют четырехуровневую структуру таблицы страниц. 48-разрядный виртуальный адрес представляет собой совокупность 5 полей: 
селектора четвертого уровня отображения страницы (биты 47-39), селектор указателя каталога страниц (биты 38-30), селектор таблицы страниц (биты 29-21), 
селектор записи таблицы страниц (биты 20-12) и байтовое смещение (биты 11-0). Эти поля служат для локализации записей в соответствующих таблицах преобразования.[11]

![Виртуальный адрес на платформе x86-64] (https://github.com/ozaitseva/diploma/blob/master/images/virt_adr.jpg "Виртуальный адрес на платформе x86-64")

![Структуры преобразования адресов на платформе x86-64](https://github.com/ozaitseva/diploma/blob/master/images/transl_adr.jpg "Структуры преобразования адресов на платформе x86-64")

Записи (такие как PDPE, PDE, PTE и др) в нижеописанных таблицах преобразования представляют собой 8-байтные значения. Биты с номерами 12-39 образуют 
значения PFN (page frame number), которые указывают на физический адрес таблицы предыдущего уровня. Оставшиеся биты — это флаги, 
указывающие на состояние страниц.

![Аппаратная запись таблицы страниц на платформе x86-64](https://github.com/ozaitseva/diploma/blob/master/images/pte.jpg "Аппаратная запись таблицы страниц на платформе x86-64")

В поставленной в данной работе задаче необходимо восстановить виртуальное адресное пространство процесса, используя снятый образ физической памяти, 
то есть провести преобразования известных виртуальных адресов в соответствующие им физические, тем самым получив данные всех страниц виртуальной памяти 
из кадров (фреймов) оперативной памяти.

Преобразования физического адреса выполняется в несколько этапов:

Шаг 1: Найти физический адрес записи расширенного каталога страниц четвертого уровня, называемого таблицей отображения страниц четвертого уровня (page map level 4), который имеет следующую структуру: 

* Биты 51-12 совпадают со значениями битов 51-12 поля DTB,
* Биты 11-3 соответствуют битам 47-39 виртуального адреса,
* Биты 2-0 равны нулю.

Шаг 2: Найти физический адрес записи структуры третьего уровня, которая называется PDPT (page directory pointer table). Физический адрес имеет аналогичный предыдущей записи вид:

* Биты 51-12 из записи таблицы PML4,
*	Биты 11-3 соответствуют битам 38-30 виртуального адреса,
*	Биты 2-0 равны нулю.

Шаг 3: Найти значение PS-флага (бит 7) записи таблицы PDPT:

*	если флаг принимает значение 1, то данная запись ссылается на большую страницу, размером 1 ГиБ. Записав PFN-номер из данной записи в биты 51-30 и значение смещения 
из виртуального адреса в биты 29-0, получаем искомый соответствующий данному виртуальному физический адрес,
*	если флаг равен нулю, то переходим к шагу 4.

Шаг 4: Найти физический адрес записи каталога страниц второго уровня - таблицы PD (page directory). Структура соответствующего физического адреса:

*	Биты 51 — 12 соответствуют битам 51-12 записи таблицы PDPT,
*	Биты 11-3 равны битам 29-21 виртуального адреса,
*	Биты 2-0 имеют нулевое значение.

Шаг 5: Найти значение PS-флага записи таблицы PD:

*	если флаг равен 1, то PDE указывает на страницу, размер которой составляет 2 МиБ. В данном случае 
получаем физический адрес, у которого значения битов 51-21 хранятся в записи таблицы PDE, а значения 20-0  - из виртуального адреса,
*	В противном случае переходим к шагу 6.

Шаг 6: Найти физический адрес записи таблицы страниц (page table):

*	биты 51-12 физического адреса записи совпадают с 51-12 битами PDE,
*	биты 11-3  - биты 20-12 виртуального адреса,
*	биты 2-0 равны нулю.

Шаг 7: Найти физический адрес соответствующий данному виртуальному:

*	Биты 51-12 из PTE-записи,
*	Биты 11-0 — смещение из виртуального адреса.

Таким образом, после преобразования получаем физический адрес, соответствующий текущему виртуальному адресу. 
Если в PTE-записи бит достоверности (0 бит) принимает нулевое значение, то это значит, что в данный момент страница недоступна процессу,
то есть данная PTE-запись предоставляет недостоверную страницу.  При ссылке на такую страницу, диспетчер памяти выдает ошибку отсутствия страницы, 
блок управления память в свою очередь игнорирует все остальные биты PTE-записи, поэтому операционная система может использовать эти биты для хранения 
информации о странице, ставшей причиной выдачи ошибки.

Существует пять видов недостоверных PTE-записей: 

1. Файл подкачки (*Page File PTE*). Биты *V* (0), *P* (10), *U* (11) равны нулю. Искомая страница находится в файле подкачки. В данном случае биты 1-4 ссылаются 
на один из шестнадцати файлов подкачки, а биты 12-51 указывают на смещение в данном файле. Файлы подкачки используются для хранения страниц, которые еще 
могут понадобиться, но места для их хранения в оперативной памяти нет, поэтому они записываются на диск. Если минимальный и максимальный размер файлов подкачки, 
на которые указывает параметр реестра *HKLM\SYSTEM\CurrentControlSet\Control\SessionManager\MemoryMange-ment\PagingFiles*, равны нулю, то это указывает на то, 
что данный файлы управляются системой. Система выбирает размер данных файлов, исходя из объемов оперативной памяти. Смещение в файле подкачки никогда не бывает 
нулевым и не может полностью состоять из единиц, то есть первая и последняя страницы из файла подкачки никогда не используются для самой подкачки. 
Найдя данную запись, необходимо вернуть соответствующие данные из файла подкачки.

2. Заполнение нулями (*Demand Zero PTE*). Данная PTE-запись совпадает с предыдущим видом, но поле, отвечающее за смещение в файле подкачки,
и поле, ссылающееся на сам файл, полностью заполнены нулями. В данном случае обработчик ошибок выберет свободную страницу из списка страниц,
заполненных нулями, а в случае, если такой список пуст, то берет свободную страницу и заполняет ее нулями, если же и свободных страниц нет, то выбирает
одну из страниц, ожидающих использования, и заполняет ее нулями. Следовательно, получив данную запись, необходимо вернуть страницу, состоящую из нулей.

3. Переходное состояние (*Transition PTE*). Бит *U* (11) содержит единицу, биты *V* (0) и *P* (10) равны нулю. Искомая страница находится в списке ожидающих использования 
или измененных, но еще не записанных страниц. Именно поэтому страница запись данного вида обрабатывается как действительная.

4. Прототипная PTE-запись (*Prototype PTE*). Бит *P* (10) равен единице. Записи таблицы страниц такого вида используется для отображения страниц, которые используются 
несколькими процессами. Формат прототипных записей таблиц страниц аналогичен формату выше рассмотренных PTE-записей. Записи данного типа имеют собственную классификацию, 
в следствие чего их обработка рассмотрена ниже.

5. Неизвестная страница (*Zero PTE*). PTE-запись заполнена нулями. С помощью диспетчера управления ошибок и VAD-дескрипторов можно узнать, был ли данный виртуальный адрес 
подтвержден. Больше никакой информации о данной странице получить невозможно.

Если бит достоверности PML4-записи, PDPT-записи или PDE равен нулю, то есть данные страницы являются недействительные, то их следует обрабатывать также, 
как *Page File PTE* или *Transition PTE*.

Особое внимание стоит уделить обработке прототипных записей. Страницы, на которые ссылаются данные записи, не используются в процессе 
преобразования адресов напрямую, а лишь являются промежуточным уровнем поиска номера страничного блока. Адрес прототипной страницы получается следующим образом:

*address = (PTE >> 16) + 0xFFFF000000000000*.

Найденная страница может находить в одном из шести состояний[13]:
 
* Активна/достоверна. Бит *V* (0) равен 1. Данная страница находится в физической памяти и обрабатывается как действительная. 
* Переходное состояние. Бит *U* (11) равен 1. Искомая страница находится в оперативной памяти и ожидает использования, либо была изменена.
При обработке необходимо вернуть страницу из памяти.
* Изменение без записи. Бит *D* (6) равен 1. Искомая страница была изменена, но не записана.  
* Заполнение нулями. Биты *P* (10), *U* (11) равны 0, а также поле, отвечающее за смещение в файле подкачки, и поле, ссылающееся на сам файл, 
имеют нулевые значения. В качестве искомой должна быть предоставлена страница, заполненная нулями.
* Страничный файл. Биты *P* (10), *U* (11) равны 0. Необходимо вернуть страницу из файла подкачки. 
* Отображаемый файл. Бит *P* (10) равен 1. Искомая страница находится в отображаемом файле. 

####Анализ реестра Windows 7x64 

Реестр в Windows  - иерархически построенная база данных параметров и настроек в большинстве операционных систем Microsoft Windows. 
Он используется приложениями ОС для хранения всевозможной информации, начиная от простых конфигурационных данных и заканчивая конфиденциальными данными, 
такими как пароли учетных записей и ключами. Реестр может быть важным источником доказательств при проведении компьютерно-криминалистических исследований.  
Он содержит такую информацию, как недавно запущенные программы, журнал недавно подключенных устройств, сетевые соединения. 

Внутреннее устройство реестра схоже с устройством дискового тома. Разделы реестра — это аналог каталогов диска, а параметры можно сравнить с файлами на диске. 
Раздел реестра состоит из подразделов или из параметров, в которых хранятся сами данные. Самые верхние разделы считаются корневыми. На диске реестр представлен 
набором файлов, которые носят название хайвов ( англ. hive).  Каждый хайв содержит дерево реестра, у которого есть раздел, служащий ему корнем или отправной точкой дерева. 
Подразделы и их параметры находятся ниже корня. Диспетчер конфигурации делит хайв на логические блоки также, как файловая система делит диск на кластеры. 
По определению, размер блока реестра составляет 4096 байт (4 Кб). Хайв хранит данные в контейнерах, которые называются ячейки. В ячейке хранятся разделы, 
параметры, список подразделов и параметров раздела. Если хайв должен быть расширен в следствие прибавления новой ячейки, создается единичный блок — приемник (англ. bin). 
За смещение ячейки в файле хайва отвечает индекс ячейки (за вычетом базового блока). Местонахождение ячейки в памяти может быть вычислено путем 
прибавления индекса ячейки к базе образа хайва. Для работы с непоследовательными адресами памяти, ссылающимися на данные хайва в памяти, 
диспетчер конфигурации заимствует стратегию, подобную той, что используется диспетчером памяти Windows для отображения адресов 
виртуальной памяти на адреса физической. 

Для отображения ячеек индекс ячейки делится на два поля: индекс в каталоге отображения ячеек и индекс в таблице отображения ячеек. 
Каталог отображения ячеек содержит 1024 записи, каждая из которых ссылается на таблицу отображения ячеек, содержащую 512 записей отображений.

Каждый хайв в ОС Windows представлен структурой *\_CMHIVE*. В структуре *\_CMHIVE* содержится метаданные о хайве, такие как полный путь, число открытых дискрипторов, и указатели на другие хайвы (структура *\_LIST\_ENTRY*). Данная структура начинается с субструктуры *\_HHIVE*, в которой содержится виртуальный адрес базового блока хайва, представленного структурой *\_HBASE_BLOCK*. 

```
typedef struct _CMHIVE {
+0x000 struct _HHIVE Hive{
+0x000 ULONG32 Signature;
...
+0x050 struct _HBASE_BLOCK* BaseBlock;
...
+0x0A8 struct _DUAL Storage[2];
}                                 
...                     
+0x5D8 struct _LIST_ENTRY HiveList;                        
...             
}
```

Поиск хайвов в физической памяти осуществляется в два этапа.

**Шаг 1**: сканируем физическую память с целью поиска структуры *\_CMHIVE*. Это сделать достаточно легко, так как подструктура данной структуры  -  *\_HHIVE* начинается с постоянного значения поля *Signature* — *0xBEE0BEE0*.

**Шаг2**: проверяем на корректность найденные структуры. Корректные структуры должны иметь pool tag *«CM10»*.

Данных показателей достаточно, чтобы найти действительные структуры *\_HHVE* в Windows 7.

Найдя соответствующие структуры, с помощью полей *HiveList.Flink* и *HiveList.Blink* можно получить виртуальные адреса последующего и предыдущего хайвов соответственно, а с помощью поля *BaseBlock* - виртуальный адрес базового блока. Далее необходимо преобразовать данные адреса в физические, используя значение *DirectoryTableBase* процесса *System*.


Основной блок хайва, представленный структурой *\_HBASE\_BLOCK* также имеет свою константную сигнатуру - *regf* или *0x66676572*. В данной структуре хранится следующая информация: имя файла, путь к файлу, временная отметка и другие системные файлы. Имя файла может содержать максимум 32 символа. Известно, что каждый основной блок содержит набор *hive bin* (*\_HBIN*). В каждой такой структуре имеется ссылка на последующую такую же структуру. Данная структура также имеет константную сигнатуру - *hbin*. 

#Литература:

[1] Федотов Н.Н., Форензика — компьютерная криминалистика, издательство, стр. 10 - 36. 

[2] Федеральный закон "О полиции" от 07.02.2011 №3-ФЗ, ст.11.

[3] Уголовно-Процессуальный кодекс Российской Федерации от 18.12.2001 № 174-ФЗ, ст.164.

[4] Carvey Harlan, Windows Forensic Analysis DVD Toolkit, Chapter 3. 

[5] Michael Hale Ligh, Andrew Case, Jamie Levy, AAron Walters, The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory, P.69.

[6]  <http://help.ubuntu.ru/wiki/kvm>

[7]  <http://habrahabr.ru/post/170259/>

[8] <https://tails.boum.org/contribute/release_process/test/erase_memory_on_shutdown/qemu_pmemsave/>

[9] <http://stackoverflow.com/questions/25479873/how-to-enable-qemu-monitor-console-in-virtual-machine-manager>

[10] <http://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Administration_Guide/sect-vish-dump.html>

[11] Russinovich M., Solomon D., Windows Internals, Fifth Edition ("Внутреннее устройство Windows, часть вторая, шестое издание"), p. 240-271. Microsoft Press, 2014.

[12] Коньков К.А., Основы организации операционных систем Microsoft Windows, Лекция 9.

[13] Russinovich M., Solomon D., Windows Internals, Fifth Edition ("Внутреннее устройство Windows, часть вторая, шестое издание"), p. 312-314. Microsoft Press, 2014.




